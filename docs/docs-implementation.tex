% Implementation section for the gr004x ecosystem
% Intended to be included from a.tex via \input{implementation}

\section{Implementation (Hardware Architecture + Toolchain)}
\label{sec:implementation}
\par This section documents the implementation of the GR0040/GR0041 FPGA softcore system and its supporting toolchain, based on Gray's compact RISC softcore design principles. The implementation is organized into four subsystems:
\begin{itemize}
    \item \textbf{CPU Core (GR0040):} 16-bit ISA execution, control/datapath split, register file, ALU, PC sequencing, and PSW/flags.
    \item \textbf{Memory Subsystem:} Harvard instruction/data access over a dual-port, byte-sliced BRAM with explicit hi/lo lanes.
    \item \textbf{Interrupt + SoC Wrapper (GR0041):} vectored interrupt controller, peripheral bus, timers, and interrupt nesting semantics.
    \item \textbf{Backend Toolchain:} a Python two-pass assembler with macro and include support, emitting BRAM-friendly hex images.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/XSOC.png}
\label{fig:impl_soc_overview}
\caption{Overview of the SoC. Figure shows three of the aforementioned subsystems: the block BRAM module, the CPU core and its interrupt wrapper, alongside other implemented peripherals. Important note: the Vectored Interrupt Controller (VIC) is not shown in this diagram (Gray's old design is shown instead) but is an integral part of the GR0041 interrupt wrapper.}
\end{figure}

\subsection{FPGA-Oriented Architectural Adaptations}
\label{subsec:fpga_mods}
\par Several modifications were required to make the original Gray-style micro-architecture fit cleanly into Xilinx 7-series FPGA fabric and to achieve stable timing closure.

\subsubsection{Removal of internal tri-state busses}
\label{subsubsec:no_tristate}
\par Gray's reference designs frequently use an \texttt{inout} data bus to model bidirectional CPU\,$\leftrightarrow$\,memory transfers. On Xilinx 7-series devices, internal tri-states are not supported in general routing (tri-states only exist at I/O boundaries). The implementation therefore replaces the bidirectional bus with two unidirectional signals:
\begin{itemize}
    \item \texttt{cpu\_do[15:0]}: CPU output to memory/peripherals (stores and ALU results).
    \item \texttt{cpu\_di[15:0]}: CPU input from memory/peripherals (loads and peripheral reads).
\end{itemize}
\par A mux in the SoC harness selects \texttt{cpu\_di} from either BRAM or MMIO read data.

\lstinputlisting[
    language=Verilog,
    caption={SoC data input mux selecting BRAM vs MMIO (\texttt{cpu\_di})},
    label={lst:soc_cpu_di_mux},
    firstline=79,
    lastline=92
]{sources_1/new/gr0041_min.v}

\subsubsection{Instruction latch and branch annul (\texttt{soc} harness)}
\label{subsubsec:if_wall}
\par The current top-level \texttt{soc} harness registers the instruction word read from BRAM into \texttt{insn\_q}. This both matches the one-cycle read latency of synchronous Block RAM and provides a clean place to annul the fall-through instruction on a taken branch by injecting a \texttt{NOP}. This avoids relying on the legacy \texttt{gr0040\_min.v} wrapper and keeps the project versioned around \texttt{gr0041\_min.v}.

\lstinputlisting[
    language=Verilog,
    caption={Instruction latch (\texttt{insn\_q}) and NOP injection on taken branch},
    label={lst:if_wall},
    firstline=40,
    lastline=56
]{sources_1/new/gr0041_min.v}

\subsubsection{Word-addressed memory (hi/lo split)}
\label{subsubsec:word_mem_model}
\par To enforce 16-bit alignment and to align with BRAM primitive structure, the memory system is implemented as two 8-bit memories (high/low lanes). Byte addressing is preserved architecturally, but word alignment is enforced at the interface by indexing BRAM with \texttt{addr[9:1]} and using \texttt{addr[0]} only for byte-lane selection on \texttt{SB}.

\subsection{CPU Core (GR0040)}
\label{subsec:gr0040}
\par The GR0040 core is implemented in \nolinkurl{sources_1/new/cpu_wrapper.v} with a strict \textbf{control/datapath separation}. The \texttt{control\_unit} is responsible for decode, stall generation, branch predicate evaluation, and interrupt gating, while the \texttt{datapath} owns stateful resources (PC, register file, PSW/flags) and combinational execution (ALU, address generation).

\begin{figure}[H]
\centering
\includegraphics[width=0.72\linewidth]{figures/ctrl_datapath.png}
\caption{GR0040 internal partitioning: control unit vs datapath}
\label{fig:impl_ctrl_datapath}
\end{figure}

\subsubsection{ISA and instruction classes}
\label{subsubsec:isa}
\par The ISA is fixed-width \textbf{16-bit} with \textbf{16 registers} (\texttt{r0--r15}). The top nibble \texttt{insn[15:12]} is the opcode. The opcode map and function codes are shared between RTL decode macros and the Python assembler (\texttt{assembler.py}). Key instruction classes:
\begin{itemize}
    \item \textbf{ALU:} RR (op=0x2) and RI (op=0x3) operations including \texttt{ADD/SUB/ADC/SBC/CMP}, \texttt{AND/XOR}, \texttt{SRL/SRA}.
    \item \textbf{Immediate:} \texttt{ADDI} (op=0x1) and \texttt{IMM} prefix (op=0x8) for full 16-bit constants/addresses.
    \item \textbf{Memory:} \texttt{LW/LB/SW/SB} (op=0x4..0x7).
    \item \textbf{Control flow:} \texttt{JAL} (op=0x0) and conditional branches (op=0x9).
    \item \textbf{System/interrupt:} \texttt{SYS} (GETCC/SETCC), \texttt{CLI}, \texttt{STI}, \texttt{NOP}.
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.42\linewidth]{figures/ISA_format.png}
\caption{Format of ISA instructions by class (RR, RI, RRI, I12, BR)}
\label{fig:impl_isa_formats}
\end{figure}

\subsubsection{Datapath vs control separation}
\label{subsubsec:split}
\par The control unit produces \texttt{insn\_ce} (instruction clock enable), \texttt{exec\_ce} (execute enable), register write enable \texttt{rf\_we}, load/store strobes, and the branch-taken decision. The datapath consumes these control signals, reads \texttt{rd/rs} operands from the register file, computes ALU results, drives store data on \texttt{cpu\_do}, and produces instruction/data addresses (\texttt{i\_ad}, \texttt{d\_ad}).

\lstinputlisting[
    language=Verilog,
    caption={Control unit: decode, stalling, branches, and global interrupt enable (excerpt)},
    label={lst:gr0040_control_unit_excerpt},
    firstline=40,
    lastline=172
]{sources_1/new/cpu_wrapper.v}

\lstinputlisting[
    language=Verilog,
    caption={Datapath: register file writeback, interrupt link saving, and GETCC PSW export (excerpt)},
    label={lst:gr0040_datapath_writeback_excerpt},
    firstline=300,
    lastline=340
]{sources_1/new/cpu_wrapper.v}

\subsubsection{PSW / flags and global interrupt enable}
\label{subsubsec:psw}
\par The CPU maintains condition codes \texttt{Z,N,C,V} plus an internal carry latch used by \texttt{ADC/SBC}. These bits are exported through \texttt{GETCC} and restored through \texttt{SETCC}. Global interrupt enable is implemented as a latched \texttt{gie} bit, controlled by \texttt{CLI/STI} and automatically cleared when an interrupt is taken.

\lstinputlisting[
    language=Verilog,
    caption={Datapath: PSW packing and SETCC-based restore of flags/carry (excerpt)},
    label={lst:gr0040_psw_restore_excerpt},
    firstline=397,
    lastline=438
]{sources_1/new/cpu_wrapper.v}

\lstinputlisting[
    language=Verilog,
    caption={Datapath: PC target selection prioritizing interrupt vector (excerpt)},
    label={lst:gr0040_irq_vector_pc_excerpt},
    firstline=470,
    lastline=474
]{sources_1/new/cpu_wrapper.v}

\subsection{Memory subsystem (Harvard BRAM, hi/lo separation)}
\label{subsec:memory}
\par The memory is implemented as a true dual-port 1\,KiB BRAM (\texttt{sources\_1/new/bram\_1kb\_be.v}) and used in Harvard mode:
\begin{itemize}
    \item \textbf{Port A:} instruction fetch at \texttt{i\_ad[9:1]}.
    \item \textbf{Port B:} data load/store at \texttt{d\_ad[9:1]} with byte enables for \texttt{SB} using \texttt{d\_ad[0]}.
\end{itemize}

\par The BRAM output registers impose a one-cycle read latency. The SoC harness therefore generates a \texttt{rdy} handshake that stalls the CPU on \texttt{LW/LB} until data is valid. The assembler emits both a combined word-hex image and the hi/lo byte streams (\texttt{mem\_hi.hex}, \texttt{mem\_lo.hex}) used for initialization.

\subsection{Interrupt wrapper (GR0041) and peripherals}
\label{subsec:gr0041}
\par Interrupt and peripheral integration is implemented by composing GR0040 with the peripheral bus and interrupt controller in the SoC harness (\nolinkurl{sources_1/new/gr0041_min.v}) and wrapper logic (\nolinkurl{sources_1/new/int_wrapper.v}).

\subsubsection{Peripheral bus}
\label{subsubsec:periph_bus}
\par Memory-mapped I/O is selected by \texttt{d\_ad[15]=1}. The peripheral bus (\nolinkurl{sources_1/new/m_periph_bus.v}) decodes \texttt{addr[11:8]} into peripheral regions. Current regions include:\; Timer0 (0x8000--0x80FF), Timer1 (0x8100--0x81FF), and the IRQ controller block (0x8F00--0x8FFF).

\begin{lstlisting}[
    language=Verilog,
    caption={Peripheral bus: address decoding, read mux, ready logic, and IRQ controller wiring},
    label={lst:periph_bus_full}
]
// periph_bus.v: Peripheral bus module
`timescale 1ns/1ps
module periph_bus
( 
    input wire         clk,
    input wire         rst, 
    input wire [15:0]  addr,
    input wire         sel,
    input wire         we,
    input wire         re,
    input wire [15:0]  wdata,
    output wire [15:0] rdata,
    output wire        rdy,
    input  wire [3:0]  par_i,
    output wire [3:0]  par_o, 
    input  wire        uart_rx,
    output wire        uart_tx,

    input wire         int_en,
    input wire         in_irq, 
    output wire [15:0] irq_vector,
    output wire        irq_take,
    input wire         irq_ret 
); 

    // Peripheral address map
    localparam [3:0] PERIPH_TIMER = 4'h0;     // Timer0: addr[11:8] = 0, range 0x8000-0x80FF
    localparam [3:0] PERIPH_TIMER1 = 4'h1;    // Timer1: addr[11:8] = 1, range 0x8100-0x81FF
    localparam [3:0] PERIPH_PARIO  = 4'h2;    // PARIO:  addr[11:8] = 2, range 0x8200-0x82FF
    localparam [3:0] PERIPH_UART_TX = 4'h3;   // UART TX: addr[11:8] = 3, range 0x8300-0x83FF (not wired) 
    localparam [3:0] PERIPH_UART_RX = 4'h4;   // UART RX: addr[11:8] = 4, range 0x8400-0x84FF (not wired)
    localparam [3:0] PERIPH_IRQ   = 4'hF;     // IRQ regs: addr[11:8] = 0xF, range 0x8F00-0x8FFF

    // Peripheral select signals
    wire sel_timer, sel_timer1, sel_pario, sel_uart, sel_irq;
    assign sel_timer  = sel && (addr[11:8] == PERIPH_TIMER);
    assign sel_timer1 = sel && (addr[11:8] == PERIPH_TIMER1);
    assign sel_pario  = sel && (addr[11:8] == PERIPH_PARIO);
    assign sel_uart   = sel && (addr[11:8] == PERIPH_UART_TX);
    assign sel_irq    = sel && (addr[11:8] == PERIPH_IRQ);

    // Ready signals from peripherals
    wire timer_rdy, timer1_rdy, pario_rdy, uart_rdy, irq_rdy;
    wire timer_int_req, timer1_int_req, pario_int_req, uart_int_req;

    // INTCAUSE bits
    localparam integer IRQ_TIMER0 = 0;
    localparam integer IRQ_TIMER1 = 1;
    localparam integer IRQ_PARIO  = 2;
    localparam integer IRQ_UART   = 3;

    // interrupt cause wiring (for sw interrupts)
    // currently we use hw vectored interrupts
    // here for legacy reasons, it can still be used if desired
    wire [7:0] int_cause;
    assign int_cause[IRQ_TIMER0] = timer_int_req;
    assign int_cause[IRQ_TIMER1] = timer1_int_req; 
    assign int_cause[IRQ_PARIO]  = pario_int_req;
    assign int_cause[IRQ_UART]   = uart_int_req;
    assign int_cause[7:4] = 4'b0;

    // read vectors
    wire [15:0] timer_rdata, timer1_rdata, pario_rdata, uart_rdata, irq_rdata;

    // timer0 
    timer16 u_timer (
        .clk(clk),
        .rst(rst),
        .sel(sel_timer),
        .we(we),
        .re(re),
        .addr(addr[2:1]), // two LSBs for reg index
        .wdata(wdata),
        .rdata(timer_rdata),
        .rdy(timer_rdy),
        .int_req(timer_int_req)
    );

    // timer1 (higher priority timer for nesting tests)
    timerH u_timer1 (
        .clk(clk),
        .rst(rst),
        .sel(sel_timer1),
        .we(we),
        .re(re),
        .addr(addr[2:1]), // two LSBs for reg index
        .wdata(wdata),
        .rdata(timer1_rdata),
        .rdy(timer1_rdy),
        .int_req(timer1_int_req)
    );

    // pario 
    pario u_pario (
        .clk(clk),
        .rst(rst),
        .sel(sel_pario),
        .we(we),
        .re(re),
        .addr(addr[1:0]), // two LSBs for reg index
        .wdata(wdata),
        .rdata(pario_rdata),
        .rdy(pario_rdy),
        .i(par_i),
        .o(par_o),
        .int_req(pario_int_req)
    );

    uart_mmio u_uart (
        .clk(clk),
        .rst(rst),
        .sel(sel_uart),
        .we(we),
        .re(re),
        .addr(addr[1:0]),
        .wdata(wdata),
        .rdata(uart_rdata),
        .rdy(uart_rdy),
        .rx_in(uart_rx),
        .tx_out(uart_tx),
        .irq_req(uart_int_req)
    );

    // two timers + irq reg => rdy logic
    assign rdy = 
            sel_timer  ? timer_rdy  : 
            sel_timer1 ? timer1_rdy :
            sel_pario  ? pario_rdy  :
            sel_uart   ? uart_rdy   :
            sel_irq    ? irq_rdy    : 
                         1'b1;

    // read mux
    assign rdata = (sel_timer && re)  ? timer_rdata  : 
                   (sel_timer1 && re) ? timer1_rdata :
                   (sel_pario  && re) ? pario_rdata  :
                   (sel_uart   && re) ? uart_rdata   :
                   (sel_irq   && re)  ? irq_rdata    :  
                                        16'h0000;

    // Instantiate the interrupt controller
    irq_ctrl u_irq_ctrl (
        .clk(clk), .rst(rst),
        .sel(sel_irq),
        .we(we),
        .re(re),
        .wdata(wdata),
        .rdata(irq_rdata),
        .rdy(irq_rdy),
        .addr(addr[3:1]),

        .src_irq(int_cause),
        .in_irq(in_irq),
        .int_en(int_en),
        .irq_take(irq_take),
        .irq_vector(irq_vector),
        .irq_ret(irq_ret)
    );

endmodule // periph_bus
\end{lstlisting}

\subsubsection{Timers}
\label{subsubsec:timers}
\par Two 16-bit timers are implemented (\nolinkurl{sources_1/new/m_timer16.v} and \nolinkurl{sources_1/new/m_timerH.v}). Each timer exposes a small register file indexed by \texttt{addr[2:1]}:
\begin{itemize}
    \item \textbf{CR0 (index 0):} \texttt{int\_en} and mode.
    \item \textbf{CR1 (index 1):} interrupt request flag (write-to-clear).
    \item \textbf{CNT (index 2):} counter readback.
\end{itemize}

\lstinputlisting[
    language=Verilog,
    caption={Timer0: 16-bit timer with MMIO control registers and interrupt request latch},
    label={lst:timer16_full}
]{sources_1/new/m_timer16.v}

\lstinputlisting[
    language=Verilog,
    caption={Timer1 (higher-priority): same MMIO interface with different reset behavior for nesting tests},
    label={lst:timerH_full}
]{sources_1/new/m_timerH.v}

\subsubsection{PARIO (parallel I/O)}
\label{subsubsec:pario}
\par The PARIO peripheral provides a simple memory-mapped parallel I/O block.

\begin{lstlisting}[
    language=Verilog,
    caption={PARIO: MMIO read/write behavior},
    label={lst:pario_full}
]
// m_pario.v: 8-bit parallel I/O peripheral (MMIO)
`timescale 1ns/1ps
module pario (
    input  wire        clk,
    input  wire        rst,
    input  wire        sel,
    input  wire        we,
    input  wire        re,
    input  wire [1:0]  addr,   // reg index
    input  wire [15:0] wdata,
    output reg  [15:0] rdata,
    output wire        rdy,

    input  wire [3:0]  i,
    output reg  [3:0]  o,
    output reg        int_req
);
    assign rdy = sel;  // single-cycle access when selected

    // Interrupt request when all inputs are high (example, more fun this way)
    always @(*) begin
        if (i == 4'hF)
            int_req = 1'b1;
        else
            int_req = 1'b0;    
    end

    // IRQ when all 4 LSB inputs are high
    always @(posedge clk) begin
        if (rst) begin
            o   <= 4'h0;
        end else if (sel && we) begin
            case (addr)
                2'b00: o   <= wdata[3:0]; // DATA
                default: ;
            endcase
        end
    end

    // Readback
    always @(*) begin
        if (!sel || !re) begin
            rdata = 16'h0000;
        end else begin
            case (addr)
                2'b00: rdata = {12'h000, o}; // read OUTPUT data
                2'b10: rdata = {12'h000, i}; // read INPUT data
                default: rdata = 16'h0000;
            endcase
        end
    end

endmodule // pario
\end{lstlisting}

\subsubsection{Vectored interrupt controller (PL190-style)}
\label{subsubsec:vic}
\par The vectored interrupt controller (\nolinkurl{sources_1/new/m_irq_ctrl.v}) implements masked pending interrupts, a fixed-priority selection, and vector address generation. A small priority stack enables limited nesting/preemption. The selected source maps to a fixed vector address (e.g., 0x0020 for Timer0, 0x0040 for Timer1). The overall programming model is intentionally reminiscent of the ARM PrimeCell PL190 family \cite{arm_pl190_trm}.

\lstinputlisting[
    language=Verilog,
    caption={Vector address generation from the selected interrupt source},
    label={lst:vic_vector_map},
    firstline=1
]{sources_1/new/m_irq_ctrl.v}

\subsubsection{UART modules (TX/RX)}
\label{subsubsec:uart}
\par The project includes synthesizable UART transmit and receive modules: \texttt{sources\_1/new/m\_uart\_tx.v} and \texttt{sources\_1/new/m\_uart\_rx.v}. Both are parameterized by \texttt{CLK\_FREQ} and \texttt{BAUD\_RATE} and compute a rounded cycles-per-bit value:
\[\texttt{BIT\_TIME} = \left\lfloor\frac{\texttt{CLK\_FREQ} + \texttt{BAUD\_RATE}/2}{\texttt{BAUD\_RATE}}\right\rfloor\]

\lstinputlisting[
    language=Verilog,
    caption={UART TX parameters, state machine, and handshake (excerpt)},
    label={lst:uart_tx_excerpt},
    firstline=1,
    lastline=55
]{sources_1/new/m_uart_tx.v}

\paragraph{UART TX}
\par The transmitter is a 4-state FSM (IDLE, START, DATA, STOP). On \texttt{tx\_start}, it latches \texttt{data[7:0]} into a shift register, emits a start bit (0), then 8 data bits LSB-first, then a stop bit (1). \texttt{tx\_busy} is asserted whenever not in IDLE and \texttt{tx\_done} pulses for one cycle when the STOP bit completes.

\paragraph{UART RX}
\par The receiver uses a 2-flop synchronizer for the asynchronous \texttt{rx\_in} signal, detects a low start bit, then samples at \texttt{HALF\_BIT} to confirm the start. Each data bit is sampled mid-bit and shifted into \texttt{shift\_reg}. The stop bit is validated; if correct, \texttt{data\_valid} and \texttt{rx\_done} pulse and \texttt{data} is updated.

\lstinputlisting[
    language=Verilog,
    caption={UART RX synchronizer and mid-bit sampling approach (excerpt)},
    label={lst:uart_rx_excerpt},
    firstline=1,
    lastline=85
]{sources_1/new/m_uart_rx.v}

\par A UART MMIO wrapper (with an RX-pending flag that can be used as an interrupt source) can be implemented as shown below. This wrapper is included here as a reference listing; the current repository snapshot does not include a \texttt{uart\_mmio} RTL module under \nolinkurl{sources_1/new/}.

\begin{lstlisting}[language=Verilog, caption={UART MMIO wrapper with RX-pending IRQ (reference listing)}, label={lst:uart_mmio_reference}]
// uart_mmio.v: UART MMIO wrapper with RX IRQ
`timescale 1ns/1ps
module uart_mmio #(
    parameter integer CLK_FREQ = 100_000_000,
    parameter integer BAUD_RATE = 115200
) (
    input  wire        clk,
    input  wire        rst,
    input  wire        sel,
    input  wire        we,
    input  wire        re,
    input  wire [1:0]  addr,
    input  wire [15:0] wdata,
    output reg  [15:0] rdata,
    output wire        rdy,

    input  wire        rx_in,
    output wire        tx_out,
    output wire        irq_req
);
    assign rdy = sel;

    reg  [7:0] tx_data;
    reg        tx_start;
    wire       tx_busy;

    wire [7:0] rx_data_wire;
    reg  [7:0] rx_data;
    reg        rx_pending;
    wire       rx_valid;

    assign irq_req = rx_pending;

    uart_tx #(
        .CLK_FREQ(CLK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) u_tx (
        .clk(clk),
        .rst(rst),
        .data(tx_data),
        .tx_start(tx_start),
        .tx_out(tx_out),
        .tx_done(),
        .tx_busy(tx_busy),
        .state_debug()
    );

    uart_rx #(
        .CLK_FREQ(CLK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) u_rx (
        .clk(clk),
        .rst(rst),
        .rx_in(rx_in),
        .data(rx_data_wire),
        .data_valid(rx_valid),
        .rx_out(),
        .rx_done(),
        .rx_busy(),
        .state_debug()
    );

    always @(posedge clk) begin
        if (rst) begin
            tx_data    <= 8'h00;
            tx_start   <= 1'b0;
            rx_data    <= 8'h00;
            rx_pending <= 1'b0;
        end else begin
            tx_start <= 1'b0;

            if (rx_valid) begin
                rx_data    <= rx_data_wire;
                rx_pending <= 1'b1;
            end

            if (sel && we) begin
                case (addr)
                    2'b00: begin
                        if (!tx_busy) begin
                            tx_data  <= wdata[7:0];
                            tx_start <= 1'b1;
                        end
                    end
                    2'b01: begin
                        if (wdata[1]) rx_pending <= 1'b0;
                    end
                    default: ;
                endcase
            end

            if (sel && re && addr == 2'b00)
                rx_pending <= 1'b0;
        end
    end

    always @(*) begin
        if (!sel || !re) begin
            rdata = 16'h0000;
        end else begin
            case (addr)
                2'b00: rdata = {8'h00, rx_data};
                2'b01: rdata = {14'b0, rx_pending, tx_busy};
                default: rdata = 16'h0000;
            endcase
        end
    end

endmodule
\end{lstlisting}

\par The UART modules exist as standalone RTL blocks. In order to be able to test them, extra hardware would be required. The available JTAG/UART Port communicates with the PS and not the fabric (Programming Logic) directly; as a result we can only verify it through testbenches. To finish integration, the complete SoC would add a UART MMIO region (new \texttt{PERIPH\_UART} decode), a small register file (TXDATA/RXDATA/STATUS/DIV), and optional interrupt sources (RX-ready, TX-empty, error) mapped into the IRQ controller's \texttt{src\_irq[]}.

\subsection{Backend toolchain: Python assembler}
\label{subsec:toolchain}
\par The toolchain assembler (\texttt{assembler.py}) is designed as the software--hardware boundary for program loading: it takes symbolic assembly, enforces word-aligned placement rules required by the 16-bit BRAM organization, and emits the exact initialization streams used by the RTL memory model (combined 16-bit words and the byte-sliced \texttt{mem\_hi.hex}/\texttt{mem\_lo.hex}).

\par It is a two-pass assembler with the following responsibilities:
\begin{itemize}
    \item \textbf{Pass 1:} symbol table construction for labels and \texttt{.equ}, and location-counter tracking (words internally, byte addresses for labels).
    \item \textbf{Pass 2:} instruction/data encoding, \texttt{.org} gap filling with \texttt{NOP} (0xF000), and emission of hi/lo byte hex streams.
    \item \textbf{Macros:} \texttt{.macro/.endm} with parameter substitution and bounded recursive expansion.
    \item \textbf{Includes:} \texttt{.include "..."} with recursive include expansion.
\end{itemize}

\lstinputlisting[
    language=Python,
    caption={Assembler pass 1: symbol table + location counter tracking (excerpt)},
    label={lst:assembler_first_pass},
    firstline=513,
    lastline=590
]{assembler.py}

\lstinputlisting[
    language=Python,
    caption={Assembler pass 2: padding .org gaps with NOP and encoding instructions/data (excerpt)},
    label={lst:assembler_second_pass},
    firstline=580,
    lastline=645
]{assembler.py}

\subsection{Structural design: ABI conventions}
\label{subsec:abi}
\par The ABI is specified in \texttt{abi.inc} and acts as the contract between handwritten assembly, compiler-generated code (where applicable), and the interrupt/exception model. It formalizes register roles (argument passing, return values, scratch temporaries, and preserved registers), standardizes a stack layout, and provides macros/pseudo-ops (e.g., \texttt{PUSH/POP}, \texttt{LI}, \texttt{CALL}, \texttt{RET}) so that independently written modules compose reliably. In practice, the ABI is what lets the project treat the GR0040 as a “real” CPU target rather than a one-off test harness: routines can be called from any context without having to invent a new calling convention just to run a different program.

\par The convention is centered on predictable register liveness across calls. A function is free to use designated caller-saved registers as scratch (the caller must assume they are clobbered by \texttt{CALL}), while callee-saved registers must be preserved by any non-leaf routine that uses them (by saving to the stack in the prologue and restoring in the epilogue). This split keeps leaf functions small and fast (requiring no stack frame if desired) while still enabling larger routines to hold long-lived state in preserved registers. Return values are provided in an agreed register (a0, and optionally a1), and multi-argument calls follow a fixed mapping of argument registers before spilling additional values to the stack.

\par The stack model follows a simple full-descending discipline: \texttt{PUSH} decrements the stack pointer and stores a word, \texttt{POP} loads a word and increments the stack pointer. This makes prologues/epilogues mechanical and easy to audit: allocate any local storage by adjusting the stack pointer, save the required preserved registers, then perform the body. For subroutine calls, \texttt{CALL} is defined as a \texttt{JAL} that also establishes the link return address (in \texttt{lr}); \texttt{RET} restores the program counter from that link register (or from a saved copy on the stack for nested calls). By expressing these patterns through macros in \texttt{abi.inc}, the codebase remains consistent even when the underlying instruction sequence changes (for example, if a future revision adds a dedicated stack pointer register or different link semantics).

\par Interrupt safety is another part of the ABI contract. We introduce a Program Status Word (PSW) representation of the condition codes and a global interrupt enable bit controlled by \texttt{CLI/STI}. Condition codes are caller-saved at the ABI level: any code that needs flags preserved across a call (or across an interrupt boundary) must explicitly snapshot them using \texttt{GETCC} and restore them using \texttt{SETCC}. For ISR prologues/epilogues, the recommended discipline is: disable interrupts as needed (\texttt{CLI}), save volatile registers plus the PSW snapshot, perform the handler, restore PSW and registers, then re-enable interrupts (\texttt{STI}) only when architecturally safe. This approach enables nested-interrupt-capable software while remaining compatible with the GR0040 datapath behavior (automatic \texttt{gie} clearing on interrupt entry and software-controlled re-enabling via \texttt{STI}).
