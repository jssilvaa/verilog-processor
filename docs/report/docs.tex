\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{margin=0.8in}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage[protrusion=true,expansion=false]{microtype}
\usepackage{fancyhdr}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{enumitem}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{url}
\usepackage{xurl}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{float}

\input{preamble}

% ---- Global styling ----
\definecolor{accent}{RGB}{0,92,184}

\hypersetup{
    colorlinks=true,
    linkcolor=accent,
    citecolor=accent,
    urlcolor=accent
}

\setlist[itemize]{topsep=0.4em,itemsep=0.2em}
\setlist[enumerate]{topsep=0.4em,itemsep=0.2em}

\titleformat{\section}
    {\Large\bfseries\color{accent}}{\thesection}{0.75em}{}[\color{accent}\titlerule]
\titleformat{\subsection}
    {\large\bfseries\color{accent}}{\thesubsection}{0.75em}{}
\titleformat{\subsubsection}
    {\normalsize\bfseries}{\thesubsubsection}{0.75em}{}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.6pt}
\renewcommand{\footrulewidth}{0pt}
\fancyheadoffset{0pt}
\addtolength{\headheight}{2pt}

\begin{document}

\input{front-cover.tex}
\tableofcontents
\newpage

\section{Document Summary}
This document provides comprehensive technical documentation of a small FPGA softcore CPU ecosystem. The work centers on adapting and extending Gray's gr0040 RISC processor\footnote{Original design reference: Designing a Simple FPGA-Optimized RISC CPU and System-on-a-Chip, available at \url{https://www.researchgate.net/publication/2922770_Designing_a_Simple_FPGA-Optimized_RISC_CPU_and_System-on-a-Chip}.} for modern Xilinx 7-series FPGAs, culminating in bare-metal execution on a Zybo Z7-10 development board. Key achievements include: (1) hardware-verified interrupt handling via a custom Vectored Interrupt Controller, (2) a complete Application Binary Interface specification, and (3) cycle-accurate post-implementation timing validation at 80MHz operational frequency.

\section{About This Guide}

\subsection{Scope and Audience}
This document is written as a programmer's guide for the \texttt{gr0040} core and the \texttt{gr0041} SoC harness. It is intended for readers who want to:
\begin{itemize}
    \item Understand the architectural contracts the RTL exposes to software (memory map, interrupt semantics, calling convention).
    \item Rebuild or modify the SoC (timing closure constraints, debug instrumentation, simulation flows).
    \item Write and debug bare-metal code using the provided assembler.
\end{itemize}

\subsection{Conventions and Notation}
\begin{itemize}
    \item \textbf{Addresses:} Unless explicitly stated otherwise, addresses are \emph{byte} addresses written in hexadecimal (e.g., \texttt{0x8F00}). The microarchitecture is internally word-oriented ($16$-bit), and several RTL modules index memory using \texttt{addr[\,\*\,:1\,]} (byte-address bit 0 is a lane selector).
    \item \textbf{Words and alignment:} A \emph{word} is $16$ bits. Word-aligned accesses have \texttt{addr[0] = 0}. The toolchain and ABI assume word alignment for code and stack.
    \item \textbf{Bit numbering:} Bit $0$ is the least-significant bit. Bit ranges are written as \texttt{[msb:lsb]}. Some vectors enforce word alignment explicitly by omitting bit $0$ (e.g., \texttt{addr[15:1]}).
    \item \textbf{Names:} RTL signals and registers are typeset as \texttt{monospace} (e.g., \texttt{irq\_take}). Instruction mnemonics and assembly symbols appear in listings and may not match any mainstream architecture syntax
\end{itemize}

\subsection{Quickstart}
\label{subsec:quickstart}

\subsubsection{Tool Versions and Host Environment}
\label{subsubsec:tool_versions}
\begin{table}[H]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Item & Version / Notes \\
\midrule
Vivado & \texttt{2025.1} \\
Board & Zybo Z7-10 \\
FPGA Part & \texttt{xc7z010clg400-1} \\
Simulator & \texttt{xsim} (Vivado) \\
Python & \texttt{3.11} (assembler) \\
OS & \texttt{Linux Ubuntu 22.04} \\
\bottomrule
\end{tabular}
\caption{Reproducibility environment}
\end{table}

\subsubsection{Repository Layout}
\label{subsubsec:repo_layout}
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,frame=single]
repo_root/
  sources_1/new/        # RTL: gr0040/gr0041, bus, timers, VIC, BRAM
  constrs_1/new/        # XDC: board constraints + optional ILA insertion
  sim_1/new/            # testbenches + wave configs
  sw/                   # assembly programs + abi.inc + vector table
  tools/assembler.py    # assembler + preprocessor
  scripts/              # (add) vivado build scripts + run recipes
\end{lstlisting}

\subsubsection{Build Firmware Image (Assembler)}
\label{subsubsec:build_firmware}
\begin{lstlisting}[language=bash]
# Example: assemble program into BRAM init images
python3 tools/assembler.py sw/main.s \
  --out sw/out/mem_words.hex \
  --hi    sw/out/mem_hi.hex \
  --lo   sw/out/mem_lo.hex
\end{lstlisting}

\subsubsection{Program Zybo and Run ILA Capture}
\label{subsubsec:program_ila}
\begin{lstlisting}[language=bash]
# Vivado Hardware Manager:
# Open target -> Program device with .bit and .ltx -> Run trigger IRQ_TAKE
\end{lstlisting}

\paragraph{Expected outputs.}
After programming, the ILA trigger \texttt{IRQ\_TAKE==1} must show PC vectoring to \texttt{0x0020} (Timer0) then \texttt{0x0040} (Timer1) and returning via \texttt{lr}, matching Fig.~\ref{fig:ila_nested_irq}.

\section{Core Architecture and FPGA Adaptation}

\subsection{The gr0040 Core Architecture}
The gr0040 is a 16-bit RISC processor optimized for FPGA implementation. Its design prioritizes efficient LUT utilization and single-cycle execution for most instructions.

\begin{figure}[H]
\centering
\includegraphics[width=0.45\linewidth]{figures/gr0040.png}
\caption{GR0040 architectural block diagram}
\label{fig:gr0040_block}
\end{figure}

\subsubsection{Instruction Set Characteristics}
\begin{itemize}
    \item \textbf{Word addressing:} All memory operations use 16-bit word boundaries. Data paths were split into high/low byte busses to enforce this constraint at the RTL level.
    \item \textbf{16 general-purpose registers:} Full 16-bit width, implemented as LUTRAM.\footnote{Vivado synthesis tools infer LUTRAM usage for small, frequently accessed memory, such as General-Purpose Registers.}
    \item \textbf{Execution timing:} Single-cycle for ALU operations and register-to-register moves. Two cycles for memory loads and control flow changes (branches, jumps).
\end{itemize}

\subsubsection{Control Unit: A 3-State Mealy Machine}
The processor uses a compact finite state machine:
\begin{itemize}
    \item \textbf{q0 (Idle/Reset):} Entry state after reset assertion.
    \item \textbf{S0 (Fetch/Decode):} Instruction fetch from BRAM, simultaneous decode begins.
    \item \textbf{S1 (Execute/Memory):} Memory access completion (waiting for memory loads).
\end{itemize}

Transitions depend on current state and input signals (\texttt{rst}, \texttt{hit}, \texttt{mem}, \texttt{rdy}). This Mealy formulation allows outputs to change immediately with inputs, reducing latency compared to Moore machines.

\begin{figure}[H]
\centering
\includegraphics[width=0.72\linewidth]{figures/control_unit.png}
\caption{Control-unit Mealy FSM (q0, S0 Fetch/Decode, S1 Execute/Memory)}
\label{fig:ctrl_fsm}
\end{figure}

\subsubsection{Critical Modifications from Gray's Original Design}
Three architectural changes were mandatory for 7-series FPGA compatibility and timing closure:

\paragraph{Removal of Tri-State Busses}
Gray's design used bidirectional \texttt{inout} ports for the data bus. Xilinx 7-series fabric lacks internal tri-state buffers---they exist only at I/O boundaries.\footnote{In practice, Vivado synthesizes internal tri-state behavior into multiplexing logic; true tri-state behavior is available at I/O via buffer primitives. See \cite{amd_ug901}.} The solution:
\begin{itemize}
    \item Split into \texttt{cpu\_di[15:0]} (input to CPU from BRAM/peripherals) and \texttt{cpu\_do[15:0]} (output from CPU).
    \item Added multiplexer logic in the SoC wrapper to arbitrate between BRAM and peripheral data sources.
\end{itemize}

\paragraph{Instruction Latch and Branch Annul (SoC Harness)}
Branches and jumps require preventing the fall-through instruction from architecturally committing when control flow changes. On FPGA BRAM-backed instruction memory, treating fetch as a synchronous interface is also essential for timing closure: the design registers the BRAM instruction output into an instruction latch (\texttt{insn\_q}) in the SoC harness and injects a \texttt{NOP} when \texttt{br\_taken} is asserted. Conceptually, this breaks the long path
\[\text{decode/nextPC} \to \text{IMEM address} \to \text{BRAM read} \to \text{instruction bus}\]
into a shorter, register-bounded interface where the fetched instruction is captured before being consumed by decode/execute. Impact on timing (measured in this project):
\begin{itemize}
    \item \textbf{Before:} Worst Negative Slack (WNS) = $-2.3$ ns at 100MHz.
    \item \textbf{After:} WNS = $+0.009$ ns at 100MHz (timing closure achieved).\footnote{For Vivado implementation timing analysis concepts and reports (WNS/TNS/WHS), see \cite{amd_ug904}.}
\end{itemize}

\begin{lstlisting}[language=Verilog, caption={Instruction latch + branch annul (excerpt from \texttt{gr0041\_min.v})}, label={fig:if_wall}]
// Instruction latch (IMEM is synchronous: captured before decode/execute)
(* mark_debug = "true" *) reg  [15:0] insn_q;
wire br_taken;

(* mark_debug = "true" *) wire [15:0] imem_dout = {imem_dout_h, imem_dout_l};
wire imem_invalid = &(~imem_dout); // all bits zero indicates invalid instruction

always @(posedge clk) begin
    if (rst | imem_invalid) begin
        insn_q <= default_nop;
    end else if (insn_ce) begin
        insn_q <= imem_dout;
        if (br_taken) begin
            insn_q <= default_nop; // annul fall-through on taken branch
        end
    end
end
\end{lstlisting}

\paragraph{Word-Addressed Memory Model}
Data was split into high/low bytes to enforce 16-bit alignment. This prevents misaligned accesses that would violate BRAM primitive constraints.\footnote{For 7-Series FPGA Block RAM organization and alignment requirements, see AMD Xilinx 7 Series FPGAs Memory Resources (UG473): \url{https://docs.amd.com/r/en-US/ug473_7Series_Memory_Resources}.} The assembler enforces byte-to-word address conversion: all labels are stored as word addresses internally, then shifted left by 1 for byte addressing when generating machine code.

\paragraph{Memory Implementations (Behavioral, BMG, Primitive)}
Three interchangeable 1~KiB memory implementations are provided, all with identical ports and cycle behavior.
\begin{itemize}
    \item \textbf{Behavioral/Inferred (\texttt{bram\_1kb\_be}):} Split hi/lo byte arrays with registered outputs and hex-based initialization. This is the functional reference in simulation.
    \item \textbf{Block Memory Generator IP (\texttt{bram\_1kb\_bmg}):} Uses a BMG IP core in synthesis/implementation and a behavioral mirror in simulation. Requires a 16-bit \texttt{.coe} or \texttt{.mif} init file.\footnote{Block Memory Generator Product Guide (PG058): \url{https://docs.amd.com/r/en-US/pg058-blk-mem-gen}.}
    \item \textbf{RAMB18E1 Primitive (\texttt{bram\_1kb\_ramb18e1}):} Direct primitive instantiation in synthesis/implementation with a behavioral mirror in simulation. Requires \texttt{INIT\_xx} parameters (256-bit chunks) derived from the same 16-bit image.\footnote{7 Series FPGA Memory Resources (UG473) covers RAMB18E1 INIT parameters: \url{https://docs.amd.com/r/en-US/ug473_7Series_Memory_Resources}.}
\end{itemize}
All three options preserve the 1-cycle read latency, byte-enable behavior, and reset values; the only difference is the backend initialization mechanism.

\subsection{Validation Strategy}
\begin{enumerate}
    \item Logically correct RTL in behavioral simulation.
    \item Functional load/store verification with BRAM primitives.
    \item Working branch (BRx) and jump-and-link (JAL) instructions.
    \item Post-synthesis functional simulation matching behavioral results.
    \item Timing simulation showing no setup/hold violations.
\end{enumerate}

\begin{table}[h]
\centering
\caption{Verification methodology}
\label{fig:verif_flow}
\begin{tabular}{llll}
\hline
\textbf{Stage} & \textbf{Scope} & \textbf{Evidence} & \textbf{Result} \\
\hline
RTL Simulation & Logical correctness & Fig 3--6 & ADDI, LOAD, STORE verified \\
Testbenches & Peripheral/ISR flow & Fig 21, 23--24 & Timer overflow, ISR tested \\
Post-Impl Timing & Setup/hold compliance & SDF annotated & WNS $+0.009$~ns @ 100~MHz \\
ILA (Silicon) & Hardware validation & Fig 38 & Nested IRQ @ 80~MHz \\
\hline
\end{tabular}
\end{table}

Verification is performed using Vivado's built-in simulator and waveform inspection, complemented by post-synthesis and post-implementation timing simulation where appropriate.
\footnote{For Vivado's functional/timing simulation workflows and post-synthesis vs. post-implementation artifacts, see \cite{amd_ug900,amd_ug901,amd_ug904}.}

\subsection{Verification of the gr0040}
The gr0040 core was verified in isolation using a testbench that instantiates the core alongside a BRAM module for instruction and data memory. The testbench provides clock and reset generation, stimulus application, and output monitoring.

\begin{lstlisting}[language=Verilog, caption={gr0040 core testbench (excerpt)}, label={fig:tb_gr0040}]
`timescale 1ns/1ps
module tb_gr0040;
  reg clk = 1'b0;
  reg rst = 1'b1;

  // 125 MHz clk
  always #4 clk = ~clk;

  gr0040_min U (.clk(clk), .rst(rst)); // instantiates gr0040 core and BRAM modules
endmodule
\end{lstlisting}

\subsubsection{RR and RRI operations}
A number of tests were carried out to verify register-to-register (RR) and register-immediate (RRI) operations. For this purpose we perform simple waveform inspection using Vivado's waveform viewer. 

First we verified the ADDI instructions by first zeroing source registers and then performing the operation. Next we checked the destination register after execution.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ver_gr0040_addi.png}
\caption{Verification of ADDI instruction in gr0040 core}
\label{fig:ver_gr0040_addi}
\end{figure}

Next, we verified arithmetic and logical operations (SUM, LOG) using similar waveform inspection techniques.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ver_gr0040_sumlog.png}
\caption{Verification of SUM and LOG instruction in gr0040 core}
\label{fig:ver_gr0040_sumlog}
\end{figure}

Next, we dealt with memory instructions, namely LOAD and STORE. We store a known value into memory, and load a known value from memory, checking the destination register after execution.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ver_gr0040_store.png}
\caption{Verification of STORE instruction in gr0040 core}
\label{fig:ver_gr0040_store}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ver_gr0040_load.png}
\caption{Verification of LOAD instruction in gr0040 core}
\label{fig:ver_gr0040_load}
\end{figure}

All remaining instructions and instruction formats were tested. Here we highlight only the key ones. 
These results confirm the logical correctness of the gr0040 core.

\section{SoC Integration: Interrupts, MMIO, and Memory Map}

\subsection{The gr0041 Interrupt Wrapper}
The \texttt{gr0041} module is the integration boundary between the \texttt{gr0040} CPU core and the SoC-level interrupt controller. It provides (i) a stable, externally visible \texttt{in\_irq} indication for peripherals/VIC logic and (ii) a place to track interrupt nesting depth at the SoC level.


\begin{figure}[H]
\centering
\includegraphics[width=0.4\linewidth]{figures/gr0041.png}
\caption{gr0041 interrupt wrapper block diagram. Figure shows connections to gr0040 core and interrupt controller. Note: Gray's original design included instruction injection logic, which has been replaced by a VIC-driven vectoring interface.}
\label{fig:gr0041_int_wrap}
\end{figure}

\subsubsection{Interrupt Interface Signals}
\begin{itemize}
    \item \texttt{irq\_take} / \texttt{irq\_vector}: driven by the interrupt controller; request immediate vectoring to the given ISR address.
    \item \texttt{int\_en}: driven by the CPU; global ``interrupts may be accepted'' qualifier (used by the controller in its \texttt{irq\_take} decision).
    \item \texttt{iret\_detected}: driven by the CPU; indicates execution of the interrupt return instruction.
    \item \texttt{in\_irq}: driven by \texttt{gr0041}; indicates that the processor is currently inside at least one interrupt service routine (including nested ISRs).
\end{itemize}

\subsubsection{Nesting Depth Tracking}
The wrapper maintains a small depth counter that is incremented on each accepted interrupt and decremented on each \texttt{IRET}. This signal is intentionally simple: it is used to inform the controller whether execution is already inside an ISR, and it provides an easy-to-probe ``are we in interrupt context? if so, how far are we?'' flag for debug.

\begin{lstlisting}[language=Verilog, caption=SoC-level IRQ depth tracking (excerpt)]
reg [1:0] irq_depth;
always @(posedge clk) begin
    if (rst) begin
        irq_depth <= 2'b00;
        in_irq    <= 1'b0;
    end else begin
        case ({irq_take, iret_detected})
            2'b10: irq_depth <= irq_depth + 3'd1;
            2'b01: irq_depth <= irq_depth - 3'd1;
            default: ;
        endcase
        in_irq <= (irq_depth != 0) | irq_take;
    end
end
\end{lstlisting}

\paragraph{Note on the original design}
Gray's design\cite{gray_design_reference} used ``instruction injection'' by forcing fetched instruction words in BRAM to synthesize a jump into a shared software vector stub. This approach is fragile on Xilinx 7-series because BRAM output reset forcing is not available in the same way as in older primitives (i.e. through the .RSTx() port present in the old Virtex FPGA family primitives.). The current design instead implements explicit hardware vectoring: the controller provides \texttt{irq\_vector} and the CPU datapath redirects the PC when \texttt{irq\_take} is asserted.

\subsection{Peripheral Bus Architecture}
The peripheral bus acts as a memory-mapped I/O controller, mediating communication between the CPU and peripherals.

\subsubsection{Address Decoding}
\begin{itemize}
    \item Peripherals occupy address space \texttt{0x8000--0x8FFF}.
    \item Decoding signal: \texttt{is\_io = d\_ad[15]} (MSB high indicates I/O access).
    \item Peripheral sub-blocks are selected by \texttt{addr[11:8]} (e.g., Timer0 at \texttt{0x8000--0x80FF}, Timer1 at \texttt{0x8100--0x81FF}, IRQCTRL at \texttt{0x8F00--0x8FFF}).
    \item The current bus implementation is single-cycle when selected\footnote{This is remarkable considering we can still run this in the range of 80-100MHz, whereas Gray's original design had not only a cycle extra of latency, in addition to running capped at 50MHz. The difference in architecture pays off here.} (\texttt{rdy = sel} for each block) and uses a read-data mux; this is primarily a microarchitectural choice rather than a special constraint trick.
\end{itemize}

\begin{figure}[H]
\centering
\begin{minipage}{0.95\linewidth}
\lstinputlisting[
    language=Verilog,
    firstline=23,
    lastline=29
]{sources_1/new/m_periph_bus.v}
\end{minipage}
\caption{Peripheral bus address decoding and MMIO selection}
\label{fig:periph_decode}
\end{figure}

\subsubsection{Timer16 Peripheral}
A pair of timer peripherals provide periodic interrupt sources. Each timer is a 16-bit up-counter; on overflow, it raises a level interrupt request that remains asserted until software clears it.

\paragraph{Register Map}
\begin{table}[H]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Address & Name & Description \\ \midrule
\texttt{0x8000} & CR\#0 & Control: \texttt{[1]=timer\_mode, [0]=int\_en} \\
\texttt{0x8002} & CR\#1 & Status: \texttt{[0]=int\_req}; write-any clears \\
\texttt{0x8004} & CNT  & Debug: current counter value (read-only) \\
\bottomrule
\end{tabular}
\caption{Timer16 register map}
\end{table}

The high-priority timer (\texttt{timerH}) exposes the same map at base \texttt{0x8100}.

\paragraph{Operational Flow}
\begin{enumerate}
    \item CPU writes to CR\#0 to enable the timer and configure mode.
    \item Counter increments each cycle.
    \item On overflow (\texttt{cnt == 0xFFFF}), \texttt{int\_req} is driven high and CR\#1[0] is set.
    \item ISR reads CR\#1, performs handling, then writes to CR\#1 to clear \texttt{int\_req}.
\end{enumerate}

\subsubsection{PARIO Peripheral}
The PARIO block provides a simple 8-bit parallel I/O interface. It is a low-latency, single-cycle MMIO peripheral intended for board-level debugging (e.g., LEDs, switches).

\paragraph{Integration status}
The RTL module exists (\texttt{m\_pario.v}) and the address map below reflects the simple MMIO integration.

\paragraph{Register Map}
\begin{table}[H]
\centering
\begin{tabular}{@{}ll>{\raggedright\arraybackslash}p{0.62\linewidth}@{}}
\toprule
Address & Name & Description \\ \midrule
\texttt{0x8200} & OUT & Write: writes to \texttt{par\_o}; Read: reads from \texttt{par\_i} \\
\texttt{0x8202} & IN & Read: reads from \texttt{par\_i} \\
\bottomrule
\end{tabular}
\caption{PARIO register map}
\end{table}

\subsection{Memory Layout and IVT Design}
The global memory map defines a low-memory interrupt region, a main code/stack region, and an MMIO region at the top of the address space.

\begin{table}[H]
\centering
\begin{tabular}{@{}ll>{\raggedright\arraybackslash}p{0.55\linewidth}@{}}
\toprule
Address Range & Region & Purpose \\ \midrule
\texttt{0x0020--0x009F} & IRQ vectors & Four fixed vector entry points (16 words each) for hardware vectoring \\
\texttt{0x0100--0x02FF} & Main code & Code region (256 words / 512 bytes) \\
\texttt{0x0300--0x03FF} & Stack & Stack region (128 words / 256 bytes) \\
\texttt{0x8000--0x8FFF} & MMIO & Peripheral registers \\
\texttt{0x8F00--0x8FFF} & IRQCTRL & Interrupt controller register block (pending, mask, force, clear) \\
\bottomrule
\end{tabular}
\caption{Global memory layout}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/memory_layout.png}
\caption{Global address space overview (IVT, code, stack, MMIO)}
\label{fig:global_mem_map}
\end{figure}

\par The IVT resides at \texttt{0x0020--0x009F}, providing four fixed vector entry points (16 words each) for hardware vectoring by the VIC. Each vector is a jump instruction to the actual ISR code located in the main code region. The IVT layout is similar to 8061-style vector tables, which use fixed offsets for each interrupt source, each with a dedicated entry point.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ivt_layout.png}
\caption{IVT Layout: fixed vector entries jumping to ISRs in main code region}
\label{fig:ivt_layout}
\end{figure}

\subsubsection{IRQCTRL Pending Bits and Software Demultiplexing (Legacy)}
Before hardware vectoring, interrupt demultiplexing can be implemented in software by reading a bitfield of interrupt causes (similar in spirit to MIPS \texttt{CP0.Cause}). In the current RTL, the interrupt-controller MMIO block exposes a \emph{pending} bitfield that serves this role:
\begin{itemize}
    \item Bit 0: Timer16 interrupt.
    \item Bit 1: High-priority timer interrupt.
    \item Bit 2: Parallel I/O interrupt. 
    \item Bit 3: UART\_TX interrupt.
    \item Bit 4: UART\_RX interrupt.
    \item Bits 5-7: Reserved for future use.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.82\linewidth]{figures/intcause.png}
\caption{INTCAUSE register: pending interrupt causes bitfield. Similar to MIPS \texttt{CP0.Cause} register.}
\label{fig:intcause}
\end{figure}

\par In the software-demultiplexing approach, ``priority'' is implicitly defined by software test order: sources checked earlier in the common handler have higher effective priority (at the cost of additional latency as the number of sources grows).

The common interrupt handler reads the pending field and branches to the appropriate ISR:
\begin{lstlisting}[language={[x86masm]Assembler}, caption=Software interrupt demultiplexing]
    ld   r1, IRQ_PEND    ; Load pending causes
    andi r1, r1, 0x01    ; Test bit 0 (Timer16)
    brz  r1, .check_next
    jal  r0, isr_timer   ; Jump to Timer16 handler
.check_next:
    ; Test other interrupt sources...
\end{lstlisting}

\textbf{Trade-off:} This polling approach introduces latency proportional to the number of interrupt sources. The VIC emerges as a more efficient solution for low-latency, hardware-prioritized interrupt handling. The INTCAUSE register remains available for diagnostics and legacy support.

\subsection{The Two-Pass Assembler}
In order to improve testing efficiency and overall development speed, the assembler is an essential subsystem and a key component of implementation. The RTL expects a deterministic BRAM initialization firmware, and the assembler is the component that enforces that contract. Beyond mnemonic encoding, it is responsible for (i) resolving symbolic control-flow targets, (ii) enforcing word alignment constraints required by the 16-bit datapath/BRAM organization, (iii) resolving macro references and file includes, and (iv) producing the exact high/low byte streams consumed by the BRAM model.

The pipeline is conceptually split into a lightweight preprocessing stage (include and macro expansion; see the preprocessor subsection later) and the classic two-pass assembly stage described below.

\begin{figure}[H]
\centering
\includegraphics[width=0.35\linewidth]{figures/assembler_flow.png}
\caption{Assembler flow: preprocessing, pass~1 (symbol table), pass~2 (encoding), output images}
\label{fig:assembler_flow}
\end{figure}

\subsubsection{Why two passes?}
Forward label references (e.g., a branch to a label defined later) and PC-relative encodings (branches) require knowing final addresses before machine code can be emitted. Pass~1 therefore computes a stable location counter and symbol table; pass~2 consumes that information to generate words and the BRAM load images.

\subsubsection{First Pass: Symbol Table Construction}
\begin{enumerate}
    \item \textbf{Lexical cleaning:} Strip comments, trim whitespace, and keep the original line text for error context.
    \item \textbf{Location Counter (LC) tracking:} Maintained in words (the machine is word-addressed internally), while labels are stored as byte addresses via \texttt{LC $\ll$ 1} to match the externally visible address space.
    \item \textbf{Directive processing and validation:}
    \begin{itemize}
        \item \texttt{.org <addr>:} Move LC to the specified \emph{byte} address (converted to words). The implementation rejects odd addresses to preserve word alignment.
        \item \texttt{.equ NAME, expr:} Define a symbolic constant (not emitted).
        \item \texttt{.word expr:} Reserve one word at the current LC.
    \end{itemize}
    \item \textbf{Output:} A symbol table plus a ``cooked'' stream of items that preserves the pass-1 PC for each line and classifies it as \texttt{None} (no emission), directive, or instruction.
\end{enumerate}

\subsubsection{Second Pass: Code Generation}
\begin{enumerate}
    \item Iterate through stored tuples.
    \item Resolve symbolic references using the symbol table.
    \item Calculate branch offsets: \texttt{displacement = (target\_addr - (PC + 2)) >> 1} (MIPS convention: PC+2 is the reference point).\footnote{MIPS PC-relative branch semantics traditionally use PC+4 for 32-bit instruction widths; for a 16-bit instruction stream, PC+2 is analogous. See "MIPS32 Architecture for Programmers" Volume II (Instruction Set), \url{https://www.mips.com/products/architectures/mips32/}.}
    \item Insert NOPs (0xF000) for gaps created by \texttt{.org} directives, ensuring a dense word image even when code is intentionally placed at fixed addresses.
    \item Enforce monotonic PC movement (\texttt{.org} cannot move backwards once emission has progressed).
    \item Split 16-bit words into high/low byte streams: \texttt{hi = (w >> 8) \& 0xFF}, \texttt{lo = w \& 0xFF}. These streams are used directly by the BRAM initialization in simulation and synthesis flows.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.82\linewidth]{figures/insn_assemble.png}
\caption{Instruction assembly: resolving labels, calculating branch offsets, emitting high/low byte}
\label{fig:insn_assemble}
\end{figure}

\subsubsection{Backend Image Conversion (COE/MIF/INIT)}
To support BRAM instantiations beyond the behavioral model, the assembler outputs can be transformed into backend-specific initialization artifacts:
\begin{itemize}
    \item \textbf{BMG COE/MIF:} The high/low byte streams are combined into 16-bit words and written as \texttt{.coe} or \texttt{.mif} files for the Block Memory Generator IP.\footnote{Initialization formats and usage are detailed in Block Memory Generator PG058: \url{https://docs.amd.com/r/en-US/pg058-blk-mem-gen}.}
    \item \textbf{RAMB18E1 INIT\_xx:} The same 16-bit words are packed into 256-bit chunks and emitted as \texttt{INIT\_00..INIT\_xx} parameter values for primitive-based instantiation.\footnote{See UG473 (7 Series Memory Resources) for INIT array packing and parameterization: \url{https://docs.amd.com/r/en-US/ug473_7Series_Memory_Resources}.}
\end{itemize}
These conversions ensure a 1:1 memory image regardless of whether the BRAM is inferred, instantiated via IP, or instantiated via primitives.

\lstinputlisting[
    language=Python,
    caption={Assembler pass 1: label/.equ handling and .org alignment checks (excerpt)},
    label={lst:assembler_first_pass_excerpt},
    firstline=513,
    lastline=578
]{assembler.py}

\subsection{Verification: Cycle-Accurate Simulation}
Standard behavioral simulation treats logic as ideal (no propagation delay). Timing simulation uses a post-synthesis or post-implementation netlist plus SDF (Standard Delay Format) backannotation so that routing/cell delays and timing checks are modeled.

\begin{figure}[H]
\centering
\includegraphics[width=0.2\linewidth]{figures/ug_simulation_logicflow.png}
\caption{Simulation flow is an iterative process that is repeated until design functionality and timing requirements are met.}
\vspace{2pt}
{\footnotesize Source: Vivado Design Suite User Guide: Logic Simulation (UG900)\cite{amd_ug900}.}
\label{fig:logicflow}
\end{figure}

\subsubsection{SDF Structure and Contents}
SDF files\footnote{IEEE Standard Delay Format (SDF), IEEE 1497-2001: \url{https://standards.ieee.org/standard/1497-2001.html}.} contain:
\begin{itemize}
    \item \textbf{Cell delays:} Propagation delays for LUTs, flip-flops.
    \item \textbf{Net delays:} Routing delays extracted from placed-and-routed design.
    \item \textbf{Timing checks:} Setup/hold (and related) checks derived from the cell timing models.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.82\linewidth]{figures/sdf.png}
\caption{SDF file structure: cell delays, net delays, timing checks.}
\vspace{2pt}
\label{fig:sdf}
\end{figure}

\paragraph{Post-Synthesis vs. Post-Implementation}
\begin{itemize}
    \item \textbf{Post-synthesis:} Contains estimated routing delays. Not suitable for final verification.
    \item \textbf{Post-implementation:} Exact routing delays, clock skew, and net RC characteristics. Command: \texttt{write\_sdf -mode timesim -process\_corner slow}.
\end{itemize}

The \texttt{-process\_corner slow} option is commonly used to stress \emph{setup} timing (slow logic paths). Note that hold timing can be stressed by a \emph{fast} corner; passing one corner does not automatically imply the other.
\footnote{See \cite{amd_ug900} for Vivado timing simulation and SDF-related flows and terminology.}

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{figures/process_corner_slow.png}
\caption{Process corner "slow": models worst-case delays for setup timing analysis.}
\vspace{2pt}
\label{fig:process_corner_slow}
\end{figure}

\subsubsection{Simulation Flow}
\begin{enumerate}
    \item \textbf{Static elaboration:} Load netlist and SDF.
    \item \textbf{Delay injection:} Annotate delays onto netlist primitives.
    \item \textbf{Create timing rules:} Setup/hold checkers inserted at all FF inputs.
    \item \textbf{Simulate:} Run testbench with annotated delays. Timing violations reported as errors.
\end{enumerate}

\par In Vivado/XSim, this “cycle-accurate” mode is still an event-driven simulation: the HDL netlist and primitives are elaborated into the simulator's compiled runtime, and the kernel advances time by consuming a queue of scheduled signal events. When a driver changes a net or a primitive output, that value-change event is propagated through the netlist according to the primitive semantics and any annotated delays.\footnote{Vivado simulation architecture and the netlist/SDF timing simulation workflow are described in \cite{amd_ug900}.}

\par The SDF file provides the delay and check information that makes this meaningful: it encodes (hierarchically) which instances receive which interconnect/cell delays, along with timing check specifications (e.g., setup/hold constraints on sequential inputs). During annotation, these values are bound to the corresponding simulated instances so that output transitions are scheduled at $t+\Delta$ instead of “immediately”, and timing checks can fire when stimulus violates the modeled constraints.\footnote{IEEE Standard Delay Format (SDF), IEEE 1497-2001: \url{https://standards.ieee.org/standard/1497-2001.html}.}

\par Waveforms are then simply a recording of these discrete events over time. As the testbench runs, XSim can dump value changes into a VCD (or similar) trace, which is later visualized as the waveform plots used throughout this report. Timing simulation therefore complements STA: it helps validate that the implemented netlist behaves correctly under annotated delays for the exercised scenarios, while STA remains the exhaustive sign-off that all constrained paths meet setup/hold requirements.\footnote{For the relationship between constraints, timing reports/STA, and implementation results, see \cite{amd_ug903,amd_ug904}.}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/simulation_flow.png}
\caption{Cycle-accurate simulation flow with SDF backannotation}
\label{fig:sdf_flow}
\end{figure}

\subsection{Constraints and Timing Closure}

\subsubsection{XDC Constraint Philosophy}
Vivado uses XDC (Xilinx Design Constraints), an industry-standard SDC. Constraints are Tcl-based commands that are parsed and applied sequentially.\footnote{See \cite{amd_ug903} for XDC/Tcl semantics, constraint sequencing, and recommended organization of timing vs. physical constraints.} Constraints fall into two broad categories:
\begin{itemize}
    \item \textbf{Physical:} Pin assignments, I/O standards, placement hints.
    \item \textbf{Timing:} Clock definitions, false paths, multicycle paths.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/xdc_constraints.png}
\caption{XDC constraints: physical (pin assignments) and timing (clock definitions)}
\label{fig:xdc_constraints}
\end{figure}

\subsubsection{Constraint Files Used}
In this repository, the checked-in constraints focus on hardware debug insertion rather than full board pinout definition:
\begin{itemize}
    \item \texttt{constrs\_1/new/ila\_const.xdc}: a Tcl/XDC script that creates an ILA debug core, configures capture depth and trigger capabilities, and binds internal nets to ILA probes.
    \item \texttt{constrs\_1/new/Zybo-Z7-Master.xdc}: the main constraints file that defines:
    \begin{itemize}
        \item Pin assignments for clock and reset inputs.
        \item Clock definition for the system clock (80-100MHz on pin K17).
        \item IO standard for clock/reset pins (LVCMOS33).
        \item Other physical constraints as needed (e.g. switches, LEDs for PARIO peripheral).
    \end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.52\linewidth]{figures/constraints_hierarchy.png}
\caption{Constraint files organization: main constraints and ILA debug insertion}
\label{fig:constraints_hierarchy}
\end{figure}

Both files are meant to be interpreted by Vivado's Tcl interpreter as part of the constraints processing sequence (either as XDC constraints or as unmanaged Tcl scripts, depending on project configuration).\footnote{Vivado distinguishes between managed XDC constraint files and unmanaged Tcl scripts (read with \texttt{read\_xdc -unmanaged} or sourced separately); the distinction affects ordering and how edits are saved back to files. See \cite{amd_ug903}.}

\subsubsection{Clock Constraint Example}
\begin{lstlisting}[language=tcl, caption=XDC clock definition]
set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33} [get_ports clk]
create_clock -name sys_clk -period 10.000 -waveform {0.000 5.000} [get_ports clk]
\end{lstlisting}

\texttt{create\_clock} informs the timing engine:
\begin{itemize}
    \item Period: 10ns (100MHz).
    \item Rising edge at 0ns, falling edge at 5ns.
    \item This propagates to all sequential elements in the clock domain.
\end{itemize}

\subsubsection{Clock Distribution: K17 Pin Selection}
The Zybo Z7-10 has dedicated clock routing resources:
\begin{itemize}
    \item \textbf{MRCC (Multi-Region Clock Capable):} Can drive multiple FPGA regions via global horizontal clock rows (HROW).
    \item \textbf{SRCC (Single-Region Clock Capable):} Limited to local regions.
\end{itemize} \footnote{For Zynq-7000 / 7-series clocking resource terminology (MRCC/SRCC and BUFG distribution), see the 7-Series Clocking Resources user guide (UG472): \url{https://docs.amd.com/r/en-US/ug472_7Series_Clocking} (accessed 2026-01-20).}

Pin K17 was chosen as an MRCC input:
\begin{itemize}
    \item Feeds BUFG (global clock buffer) $\to$ HROW spine $\to$ all clock regions.
    \item Minimizes clock skew across the die.
    \item Enables clean ILA capture (Integrated Logic Analyzer requires low-skew clocking).
\end{itemize} \footnote{Board-specific pin assignments and clock-capable pin information are documented in the Zybo Z7 hardware reference materials: \url{https://digilent.com/reference/programmable-logic/zybo-z7/start} (accessed 2026-01-20).}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/pin_k17.png}
\caption{Zybo Z7-10 clock-capable pin K17 (MRCC) for system clock input}
\label{fig:pin_k17}
\end{figure}

\subsubsection{Timing Report Analysis}
Vivado's timing summary provides:
\begin{itemize}
    \item \textbf{WNS (Worst Negative Slack):} Most critical path's timing margin. Must be $\geq 0$ for correct operation.
    \item \textbf{TNS (Total Negative Slack):} Sum of all negative slacks. Zero indicates all paths meet timing.
    \item \textbf{WHS (Worst Hold Slack):} Minimum hold time margin.
\end{itemize}

\par These metrics are computed by Vivado's static timing analysis (STA) engine: rather than simulating a particular waveform, STA analyzes timing constraints (clocks, I/O constraints, exceptions) and evaluates 
\emph{all} feasible register-to-register (and I/O) paths in the implemented netlist. Using the post-place-and-route delay model (logic + routing + clock tree), Vivado computes arrival/required times and reports slack for both setup and hold checks.\footnote{For Vivado implementation timing analysis concepts and reports (STA, setup/hold, WNS/TNS/WHS), see \cite{amd_ug904}.}

\par In practice, WNS/TNS are typically dominated by the worst-case \emph{setup} corner (slow timing), while hold closure can be stressed by a \emph{fast} corner. For that reason, a design that is functionally correct in simulation may still fail STA if a small number of paths violate setup/hold margins; timing closure therefore becomes a first-class design loop alongside functional verification.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/path-breakout.png}
\caption{Timing critical path: inserting a register boundary (instruction latch) breaks a long combinational path into shorter segments, improving slack.}
\label{fig:timing_critical_path}
\end{figure}

\par Note that timing closure is an iterative process: paths are analyzed, bottlenecks identified, and design optimizations applied (e.g., pipelining, logic restructuring) until all timing requirements are satisfied.

\par The final SoC harness uses an instruction latch (\texttt{insn\_q}) and branch annul (NOP injection on taken branches) rather than the earlier "IF wall" experiment; the example remains useful because it illustrates how STA pinpoints the specific long paths that motivate adding register boundaries and restructuring hot control nets.

\paragraph{Path Analysis Example}
A failing path before instruction-latch insertion (example):
\begin{verbatim}
Source: u_cpu/u_dp/regfile/r1_reg[15]
Destination: instruction-latch / fetch-control register
Data Path Delay: 12.3ns
Clock Period: 10.0ns
Slack: -2.3ns
Levels: 8
Fanout: 12
\end{verbatim}

The path traverses: regfile $\to$ ALU $\to$ memory mux $\to$ fetch/control gating. High fanout on the shared ready/control signals adds significant routing delay. Registering the instruction interface (\texttt{insn\_q} latch) and pipelining hot control nets splits this into shorter paths, improving slack under the same clock constraint.

\subsection{Integration Verification}
Integration is verified through a combination of unit-level and system-level simulation:
\begin{itemize}
    \item \textbf{Wrapper/interrupt integration:} simulation confirms correct interrupt entry/return sequencing and nesting behavior (\texttt{irq\_take}/\texttt{irq\_vector} acceptance, \texttt{iret\_detected}, and \texttt{in\_irq} tracking).
    \item \textbf{Timer peripherals:} dedicated testbenches validate interrupt request assertion on overflow and software-visible status clearing semantics.
    \item \textbf{Cycle-accurate timing simulation:} post-implementation netlist + SDF runs provide a delay-annotated functional check under extracted routing delays.
    \item \textbf{Memory layout contract:} the IVT spacing and MMIO region mapping are defined to match the current RTL decode and fixed vector addresses.
    \item \textbf{Toolchain contract:} the assembler resolves symbolic references, enforces alignment constraints, and emits BRAM initialization images consistent with the hi/lo lane organization.
\end{itemize}

\subsection{Timer Verification}
\par In this subsection we verify the Timer16 peripheral. A simple testbench instantiates the Timer16 module and simulates its counting and interrupt request behavior.

\begin{lstlisting}[language=Verilog, caption=Timer16 testbench (tb\_test16.v)]

module tb_test16;
    reg clk = 0; 
    reg rst = 1; 
    reg sel = 0; 
    reg we = 0; 
    reg re = 0;
    reg [2:0] addr = 0;
    reg [15:0] wdata = 16'h0000;
    wire [15:0] rdata;
    wire rdy; 
    wire int_req; 

    timer16 dut (
        .clk(clk),
        .rst(rst),
        .sel(sel),
        .we(we),
        .re(re),
        .addr(addr),
        .wdata(wdata),
        .rdata(rdata),
        .rdy(rdy),
        .int_req(int_req)
    );
    always #5 clk = ~clk; // 10ns clock period

    task write_reg(input [2:0] address, input [15:0] data); 
        begin
            @(posedge clk); 
            sel = 1; we = 1; re = 0; 
            addr = address; 
            wdata = data;
            @(posedge clk); 
            sel = 0; we = 0; 
            $display("Wrote 0x%h to reg %0d at time %t", data, address, $time);
        end
    endtask // write_reg 

    task read_reg(input [2:0] address); 
        begin
            @(posedge clk); 
            sel = 1; we = 0; re = 1; 
            addr = address; 
            @(posedge clk); 
            sel = 0; re = 0; 
            $display("Read 0x%h from reg %0d at time %t", rdata, address, $time);
        end
    endtask // read_reg 

    task wait_clocks(input integer n);
        repeat (n) @(posedge clk);
    endtask // wait_clocks

    // Test sequence
    initial 
    begin
        wait_clocks(5); 
        rst = 0; 
        // Preload counter near overflow
        force dut.cnt = 16'hFFF8; // preload counter near overflow
        $display("Counter preloaded to 0x%h at time %t", dut.cnt, $time);
        #1; release dut.cnt;      // release forced value

        // Read initial values
        read_reg(3'b000); // CR#0
        read_reg(3'b001); // CR#1
        wait_clocks(1); 

        // Perform a write to CR#0 
        write_reg(3'b000, 16'h0003); // int_en = 1; timer_mode = 1
        
        wait(int_req == 1); 
        $display("Interrupt requested at time %t", $time);

        // Perform a write to CR#1 to clear int_req
        write_reg(3'b001, 16'h0000);

        wait_clocks(10); 
        $finish;
    end

    initial #100000 $display("Timeout: test didn't finish"); // timeout 

endmodule // tb_test16
\end{lstlisting}

\par The testbench performs the following steps:
\begin{enumerate}
    \item Resets the Timer16 peripheral.
    \item Preloads the counter to a value near overflow (0xFFF8).
    \item Reads initial control and status registers.
    \item Writes to CR\#0 to enable the timer and interrupt.
    \item Waits for the interrupt request to be asserted on overflow.
    \item Writes to CR\#1 to clear the interrupt request.
\end{enumerate}

\par Tasks procedural blocks are used to encapsulate register read/write operations and clock waiting. The testbench prints informative messages to the console for visibility into the peripheral's behavior.

\par The waveform output confirms correct operation:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{figures/timer_waveform.png}
\caption{Timer16 waveform: counter overflow triggers int\_req; software clears it via CR\#1 write.}
\label{fig:timer16_waveform}
\end{figure}

\subsection{Interrupt Handling}

\par The interrupt handling mechanism is a critical component of the CPU architecture, enabling asynchronous event processing. Gray's original design handles interrupts according to the waveform as follows: 

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/interrupt_clearing_flow_waveform.png}
\caption{Interrupt handling flow: interrupt request, jump to ISR entrypoint, ISR execution, and return. As per Gray's original design.}
\label{fig:interrupt_flow_waveform}
\end{figure}

\subsubsection{Software Interrupts}

\par For starters, software interrupt handling was implemented alongside gray's original design using a polling-based approach (using the INTCAUSE register). The CPU reads a pending interrupt causes register and branches to the appropriate ISR based on which bits are set. This method is straightforward but introduces latency proportional to the number of interrupt sources.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/interrupts_software_waveform.png}
\caption{Software interrupt handling waveform: CPU polls INTCAUSE register to determine active interrupt source and branches to corresponding ISR.}
\label{fig:interrupts_software_waveform}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/IRET_stub_waveform.png}
\caption{Software interrupt handling waveform (continuation): ISR executes and performs IRET to return from interrupt.}
\label{fig:iret_stub_waveform}
\end{figure}

\section{Software Interface: ABI and Interrupt Controller}

\subsection{Motivation: Why Define an ABI?}
An Application Binary Interface establishes invariants for software interoperability. In this context, it provides:
\begin{enumerate}
    \item \textbf{Testability:} Fixed conventions allow systematic verification of call/return semantics.
    \item \textbf{Compiler readiness:} Future C compiler backends can target this ISA with known register usage rules.
    \item \textbf{Nested function support:} Callee-saved register conventions enable deep call stacks without register corruption.
\end{enumerate}

\subsection{ABI Specification: Register Allocation}
The 16-register file is partitioned following MIPS o32 and ARM AAPCS conventions \cite{gcc_mips_options,arm_aapcs32}.\footnote{ARM Procedure Call Standard for the ARM Architecture (AAPCS), IHI 0042E: \url{https://developer.arm.com/documentation/ihi0042/latest}.}:

\begin{table}[H]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
Register & Alias & Usage & Saved By \\ \midrule
r0 & zero & Always reads 0, writes ignored & --- \\
r1 & a0/v0 & Argument 0 / Return value & Caller \\
r2 & a1 & Argument 1 & Caller \\
r3 & a2 & Argument 2 & Caller \\
r4--r7 & t0--t3 & Temporaries & Caller \\
r8--r11 & s0--s3 & Saved registers & Callee \\
r12 & fp & Frame pointer & Callee \\
r13 & sp & Stack pointer & Callee \\
r14 & lr & Link register (return address) & Callee \\
r15 & gp & Global pointer (unused currently) & --- \\
\bottomrule
\end{tabular}
\caption{ABI register conventions}
\end{table}

\subsubsection{Caller vs. Callee-Saved Semantics}
\paragraph{Caller-saved (volatile):} Registers \texttt{a0--a2, t0--t3} may be clobbered by function calls. If a caller needs these values preserved, it must save them before calling.

\paragraph{Callee-saved (non-volatile):} Registers \texttt{s0--s3, fp, sp, lr} must be preserved across calls. A function using these registers must:
\begin{lstlisting}[language={[x86masm]Assembler}, caption=Callee-saved register preservation]
func_prologue:
    sub  sp, sp, 8       ; Allocate stack frame
    st   lr, [sp, 0]     ; Save return address
    st   s0, [sp, 2]     ; Save s0 if used
    ; Function body...
func_epilogue:
    ld   s0, [sp, 2]     ; Restore s0
    ld   lr, [sp, 0]     ; Restore return address
    add  sp, sp, 8       ; Deallocate frame
    jal  r0, lr, 0       ; Return
\end{lstlisting}

\subsection{Stack Model}
\begin{itemize}
    \item \textbf{Initial SP:} \texttt{0x03FF} (top of 128-word stack region).
    \item \textbf{Growth direction:} Downward (decrementing addresses).
    \item \textbf{Alignment:} 8-byte (4-word) alignment enforced by convention. Simplifies structure padding for future C compiler.\footnote{The AAPCS specifies 8-byte stack pointer alignment at public interfaces; see \cite{arm_aapcs32}.}
\end{itemize}

\subsection{Leaf vs. Non-Leaf Functions}
\paragraph{Leaf functions:} Do not call other functions. May use caller-saved registers without touching the stack. Example:
\begin{lstlisting}[language={[x86masm]Assembler}]
add3:               ; int add3(int a, int b, int c)
    add  a0, a0, a1  ; a0 = a0 + a1
    add  a0, a0, a2  ; a0 = a0 + a2
    jal  r0, lr, 0   ; Return
\end{lstlisting}

\paragraph{Non-leaf functions:} Call other functions. Must save \texttt{lr} to stack before making calls. Example:
\begin{lstlisting}[language={[x86masm]Assembler}]
caller:
    sub  sp, sp, 2    ; Allocate frame
    st   lr, [sp, 0]  ; Save return address
    jal  lr, add3     ; Call add3, lr = PC+2
    ld   lr, [sp, 0]  ; Restore return address
    add  sp, sp, 2    ; Deallocate frame
    jal  r0, lr, 0    ; Return
\end{lstlisting}

\subsection{The Vectored Interrupt Controller (VIC)}
Software polling was replaced with hardware vectoring inspired by ARM's PrimeCell PL190 \cite{arm_pl190_trm}.\footnote{PrimeCell Vectored Interrupt Controller (PL190) Technical Reference Manual (DDI0181): \url{https://developer.arm.com/documentation/ddi0181/latest}.}

\subsubsection{VIC Architecture}
The VIC maintains per-source state:
\begin{itemize}
    \item \textbf{Enable mask:} An 8-bit mask register (one bit per potential IRQ source).
    \item \textbf{Pending bits:} Latched requests (level-sensitive sources are ORed into pending while asserted and enabled).
    \item \textbf{Servicing bits:} A per-source ``in service'' latch to prevent immediate re-latching while a source remains asserted.
    \item \textbf{Priority encoder:} A fixed-priority encoder selects the highest-priority pending source currently implemented.
    \item \textbf{Vector mux:} Produces a 16-bit \texttt{IRQ\_VECTOR} address. The current RTL provides fixed vectors for IRQ0--IRQ3.
\end{itemize}

\paragraph{IRQCTRL MMIO Register Map}
The VIC is accessed via the \texttt{0x8F00--0x8FFF} MMIO block. The current RTL implements the following word-aligned registers:

\begin{table}[H]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
Address & Name & Access & Description \\ \midrule
\texttt{0x8F00} & \texttt{IRQ\_PEND}  & R   & Latched pending causes (bits [7:0]) \\
\texttt{0x8F04} & \texttt{IRQ\_MASK}  & R/W & Enable mask (bits [7:0]) \\
\texttt{0x8F08} & \texttt{IRQ\_FORCE} & W1  & Set pending bits (bitwise OR with \texttt{wdata[7:0]}) \\
\texttt{0x8F0C} & \texttt{IRQ\_CLEAR} & W1  & Clear pending bits (bitwise AND with inverted \texttt{wdata[7:0]}) \\
\bottomrule
\end{tabular}
\caption{IRQ controller register map (\texttt{IRQCTRL} block)}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/vic_arch.png}
\caption{Vectored Interrupt Controller (VIC) architecture}
\label{fig:vic_arch}
\end{figure}

\subsubsection{Interrupt Flow}
\begin{enumerate}
    \item Peripheral asserts \texttt{src\_irq[N]}.
    \item VIC checks: (1) \texttt{src\_irq[N]} enabled, (2) not already in service, (3) CPU \texttt{int\_en == 1}.
    \item If all conditions met: assert \texttt{IRQ\_TAKE}, drive \texttt{IRQ\_VECTOR} with ISR address.
    \item CPU:
    \begin{itemize}
        \item Saves PC to \texttt{lr} (r14).
        \item Loads \texttt{IRQ\_VECTOR} into PC.
        \item Clears \texttt{int\_en} to prevent immediate re-entry.
    \end{itemize}
    \item ISR executes, clears interrupt source.
    \item ISR executes \texttt{IRET}, which sets \texttt{iret\_detected}.
    \item VIC deasserts \texttt{IRQ\_TAKE}, allowing next interrupt.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/interrupt_flow.png}
\caption{Interrupt request logic. Figure taken from ARM PL190 TRM \cite{arm_pl190_trm}.}
\label{fig:irq_sequence}
\end{figure}

\subsubsection{Priority Encoding}
Higher IRQ numbers have higher priority:
\begin{lstlisting}[language=Verilog, caption=Priority encoder (simplified)]
always @(*) begin
    // current implementation selects among IRQ[3:0]
    casex (pending_masked[3:0])
        4'b1xxx: sel_idx = 3;
        4'b01xx: sel_idx = 2;
        4'b001x: sel_idx = 1;
        4'b0001: sel_idx = 0;
        default: sel_idx = 0;
    endcase
end
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=0.52\linewidth]{figures/vic_priority_encoder.png}
\caption{VIC priority encoder logic: selects highest-priority pending interrupt source.}
\label{fig:vic_priority_encoder}
\end{figure}

\subsection{Pending logic}
\par The VIC's pending logic ensures that level-sensitive interrupt sources are latched correctly and not re-asserted while being serviced.

\begin{figure}[H]
\centering
\includegraphics[width=0.62\linewidth]{figures/vic_pending_logic.png}
\caption{VIC pending logic: latches level-sensitive interrupt requests and manages in-service state.}
\label{fig:vic_pending_logic}
\end{figure}

\subsection{Taking interrupts}
\par The CPU takes interrupts based on the VIC's \texttt{IRQ\_TAKE} signal and \texttt{IRQ\_VECTOR} address. The following RTL diagram illustrates the interrupt-taking mechanism:

\begin{figure}[H]
\centering
\includegraphics[width=0.72\linewidth]{figures/vic_main_arch.png}
\caption{RTL Block Diagram of the Vectored Interrupt Controller (VIC), how IRQ\_TAKE is produced.}
\label{fig:vic_main_arch}
\end{figure}

\subsection{Updated Memory Layout}
IVT expanded to support 4 vectored entries:

\begin{table}[H]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Address & ISR Handler \\ \midrule
\texttt{0x0020--0x003F} & IRQ 0 (16 words max) \\
\texttt{0x0040--0x005F} & IRQ 1 (16 words max) \\
\texttt{0x0060--0x007F} & IRQ 2 (16 words max) \\
\texttt{0x0080--0x009F} & IRQ 3 (16 words max) \\
\texttt{0x0100--0x02FF} & Main code region (256 words) \\
\texttt{0x0300--0x03FF} & Stack (128 words) \\
\bottomrule
\end{tabular}
\caption{Updated IVT layout}
\end{table}

\subsection{Assembler Enhancements: Preprocessor}
The assembler includes a preprocessor to support macros and includes.

\subsubsection{Macro System}
Defined in \texttt{abi.inc}:
\begin{lstlisting}[language={[x86masm]Assembler}, caption=Example ABI macros]
.macro PUSH reg
    sub  sp, sp, 1
    st   \reg, [sp, 0]
.endmacro

.macro POP reg
    ld   \reg, [sp, 0]
    add  sp, sp, 1
.endmacro

.macro CALL target
    jal  lr, \target
.endmacro

.macro RET
    jal  r0, lr, 0
.endmacro
\end{lstlisting}

\subsubsection{Preprocessing Pipeline}
\begin{enumerate}
    \item \textbf{Read source file.}
    \item \textbf{Expand includes:} Recursively insert \texttt{.include "file"} contents.
    \item \textbf{Expand macros:} Replace macro invocations with body, substituting parameters.
    \item \textbf{Feed to assembler:} Resulting text processed by existing two-pass logic.
\end{enumerate}

This functional-style pipeline (read $\to$ expand\_includes $\to$ expand\_macros) maintains modularity and allows independent testing of each stage.

\subsection{Post-Implementation Verification}
A test program \texttt{add3(1,2,3)} was written to validate ABI compliance:
\begin{lstlisting}[language={[x86masm]Assembler}]
main:
    li   a0, 1
    li   a1, 2
    li   a2, 3
    CALL add3
    ; a0 now contains 6
    halt
\end{lstlisting}

Post-implementation timing simulation confirmed:
\begin{itemize}
    \item Arguments correctly passed in \texttt{a0--a2}.
    \item Return value correctly placed in \texttt{a0}.
    \item No register corruption (caller-saved registers remain unchanged).
\end{itemize}

\subsection{ABI and Interrupt Controller Verification}
The ABI and interrupt-controller programming model are validated with small, deterministic programs and simulation checks:
\begin{itemize}
    \item \textbf{ABI conformance:} calling/return conventions are exercised with simple test programs (e.g., \texttt{add3}) to confirm argument passing, return values, and register preservation.
    \item \textbf{VIC functionality:} hardware vectoring is checked by asserting interrupt sources and observing deterministic PC redirection to the fixed vector entry points.
    \item \textbf{Preprocessor behavior:} macro expansion and include processing are validated by assembling programs that use ABI helper macros and shared include files.
    \item \textbf{Memory layout consistency:} the IVT layout is kept aligned with the fixed-vector map implemented by the RTL.
\end{itemize}

\section{Advanced Interrupts and Hardware Validation}

\subsection{Problem: Condition Code Corruption}
Consider this scenario:
\begin{lstlisting}[language={[x86masm]Assembler}]
main:
    cmp  r1, r2       ; Sets Z flag
    ; <-- Interrupt arrives here
    brz  target       ; Branch depends on Z flag
\end{lstlisting}

If an interrupt arrives between \texttt{cmp} and \texttt{brz}, the ISR's ALU operations will overwrite condition codes, causing incorrect branch behavior.

\subsection{Solution: Program Status Register (PSR)}
Modeled after ARM's CPSR (Current Program Status Register).

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/PSR.png}
\caption{Program Status Register (PSR) layout, adapted from \href{https://developer.arm.com/documentation/111107/2025-09/AArch32-Registers/CPSR--Current-Program-Status-Register}{ARM CPSR documentation}.}
\label{fig:psr_layout}
\end{figure}

\subsubsection{PSR Layout}
\begin{table}[H]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Bit & Meaning \\ \midrule
0 & Zero (Z) \\
1 & Carry (C) \\
2 & Negative (N) \\
3 & Overflow (V) \\
4 & Carry latch (for multi-precision arithmetic) \\
\bottomrule
\end{tabular}
\caption{PSR bit assignments}
\end{table}

\subsubsection{New Instructions: GETCC and SETCC}
Analogous to ARM's \texttt{MRS} (Move to Register from Special) and \texttt{MSR} (Move to Special from Register).\footnote{ARMv7-A/R Architecture Reference Manual (DDI0406C): \url{https://developer.arm.com/documentation/ddi0406/latest}.}:

\begin{lstlisting}[language={[x86masm]Assembler}, caption=Preserving condition codes]
isr_entry:
    GETCC t0          ; t0 = PSR[4:0]
    PUSH  t0          ; Save to stack
    ; ISR body (may modify flags)
    POP   t0          ; Restore flags
    SETCC t0          ; PSR[4:0] = t0
    IRET
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/getcc_setcc.png}
\caption{GETCC/SETCC instruction flow: save/restore condition codes around ISR execution.}
\label{fig:getcc_setcc}
\end{figure}

\par \texttt{GETCC} reads the PSR's condition code bits into a general-purpose register. \texttt{SETCC} writes the register value back to the PSR, restoring the flags.

\par These instructions allow ISRs to preserve the caller's condition codes, preventing corruption during interrupt handling.

\par We implemented these instructions under the RR format, reusing existing instruction decoding infrastructure, as shown in \ref{fig:getcc_setcc}. Both instructions are \texttt{SYS} class instructions (named after system instructions in ARM), simplifying their integration into the existing architecture and taking advantage of the existing freely available opcode space.

\subsubsection{RTL Implementation}
\begin{lstlisting}[language=Verilog, caption=GETCC/SETCC logic]
always @(posedge clk) begin
    if (is_getcc)
        rd <= {11'b0, carry_latch, cc_flags};
    if (is_setcc)
        {carry_latch, cc_flags} <= rs[4:0];
end
\end{lstlisting}

\subsection{ABI Extension: Caller-Saved Flags}
\begin{itemize}
    \item \textbf{Function calls:} Condition codes are caller-saved. If a caller needs flags preserved across a call, it must save/restore them via \texttt{GETCC}/\texttt{SETCC}.
    \item \textbf{Interrupt handlers:} Must always preserve flags since interrupts are asynchronous. Standard ISR prologue includes \texttt{GETCC}/\texttt{PUSH}, epilogue includes \texttt{POP}/\texttt{SETCC}.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/flag_preservation.png}
\caption{ISR flag preservation using GETCC/SETCC around the interrupt service routine. After interrupt, the original condition codes are restored through the stack.}
\label{fig:flag_preservation}
\end{figure}

\subsection{Nested Interrupts}
The non-preemptive VIC behavior blocks all interrupts during ISR execution. The nested-interrupt extension adds priority-based preemption.

\subsubsection{In-Service Stack}
Instead of a single \texttt{in\_int} flag, the VIC maintains:
\begin{itemize}
    \item \textbf{Depth counter:} Tracks nesting level (current RTL: max depth = 2).
    \item \textbf{Priority stack:} Stores the priority of the currently executing ISR at each depth level.
\end{itemize}

\begin{lstlisting}[language=Verilog, caption=Priority stack (simplified)]
localparam DEPTH = 2;
reg [DEPTH-1:0] depth;
reg [2:0] pri_stack [DEPTH-1:0];

always @(posedge clk) begin
    if (irq_take && (depth < DEPTH)) begin
        pri_stack[depth] <= sel_idx;
        depth <= depth + 1'b1;
    end
    if (iret_detected && (depth > 0)) begin
        depth <= depth - 1'b1;
    end
end
\end{lstlisting}

\par The priority stack mechanism is illustrated in Figures~\ref{fig:priority_stack_first} and \ref{fig:priority_stack_second}. When a higher-priority interrupt arrives, the current priority is pushed onto the stack, and depth is incremented. Upon \texttt{IRET}, depth is decremented, restoring the previous priority.

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/priority_stack_first.png}
\caption{Depth and priority stack mechanism for nested interrupts. Each time an interrupt is taken, the current priority is pushed onto the stack. Upon IRET, the previous priority is restored. Here Timer1 (higher priority) preempts Timer0, pushing its priority onto the stack, incrementing depth.}
\label{fig:priority_stack_first}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/priority_stack_second.png}
\caption{Depth and priority stack mechanism for nested interrupts (continuation). Upon IRET from Timer1, depth is decremented, restoring Timer0's priority from the stack, allowing it to resume execution.}
\label{fig:priority_stack_second}
\end{figure}

\subsubsection{Preemption Logic}
A new interrupt is accepted only if:
\begin{enumerate}
    \item \texttt{int\_en == 1} (global interrupt enable).
    \item New IRQ's priority $>$ \texttt{priority\_stack[depth-1]}.
    \item Depth $<$ max nesting level (2).
\end{enumerate}

\subsection{CLI and STI Instructions}
To prevent preemption during context save/restore, two instructions were added:
\begin{itemize}
    \item \textbf{CLI (Clear Interrupts):} Clears global interrupt enable. Disables all interrupt acceptance.
    \item \textbf{STI (Set Interrupts):} Sets global interrupt enable. Re-enables interrupt acceptance.
\end{itemize}

\par In a nested-interrupt system, the key correctness requirement is that the architectural context is saved and restored atomically. If an ISR is interrupted part-way through saving registers (or flags/condition codes), the higher-priority handler may observe a partially-saved frame or overwrite state that the interrupted handler has not yet preserved, leading to subtle corruption on return. The CLI/STI pair provides an explicit, ISA-level mechanism to bound those critical sections so that context management and interrupt control are decoupled from any specific peripheral.

\par This is also a practical latency trade-off: keeping interrupts masked for the entire ISR maximizes simplicity but increases worst-case response time for high-priority events. Re-enabling interrupts immediately after the prologue (and masking again only for the epilogue) allows preemption while the handler body runs, while still guaranteeing that the entry/exit sequences are indivisible. This is conceptually similar to the global interrupt mask/enable patterns found in many interrupt controller and ABI ecosystems, where handlers must preserve calling-context invariants while remaining responsive to higher-priority requests.\footnote{For an example of a vectored interrupt controller model and the relationship between global enable and interrupt handling, see \cite{arm_pl190_trm}. For calling convention and context-preservation requirements, see \cite{arm_aapcs32}.}

\begin{figure}[H]
\centering
\includegraphics[width=0.62\linewidth]{figures/cli_sti.png}
\caption{CLI/STI instruction flow: disable interrupts during critical sections (context save/restore), re-enable afterward.}
\label{fig:cli_sti}
\end{figure}

\par Overall, these instructions allow ISRs to safely manage interrupt acceptance during sensitive operations.

\subsubsection{ISR Prologue/Epilogue with Nesting}
\begin{lstlisting}[language={[x86masm]Assembler}, caption=Nested interrupt-safe ISR]
isr_timer:
    CLI               ; Disable interrupts during context save
    PUSH lr
    PUSH s0
    GETCC t0
    PUSH t0
    STI               ; Re-enable interrupts (allow preemption)
    
    ; ISR body...
    
    CLI               ; Disable interrupts during context restore
    POP  t0
    SETCC t0
    POP  s0
    POP  lr
    STI
    IRET
\end{lstlisting}

% global interrupt enable
\par The ISR prologue disables interrupts during context saving, re-enables them for the ISR body (allowing preemption), and disables them again during context restoration before executing \texttt{IRET}.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{figures/global-interrupt-enable.png}
\caption{Global interrupt enable management in nested ISRs using CLI/STI to control interrupt acceptance during context save/restore.}
\label{fig:global_interrupt_enable}
\end{figure}

\par This approach ensures that the CPU can handle nested interrupts correctly while preserving the integrity of the execution context, and therefore complying with the ABI standards.\footnote{See \cite{arm_aapcs32} for baseline ABI expectations around register preservation and call boundaries; the same principles motivate ISR prologue/epilogue structure when integrating interrupts with software conventions.}

\subsection{Hardware Validation: ILA on Zybo Z7-10}
The Integrated Logic Analyzer (ILA) was configured to capture real-time signals from the FPGA fabric.\footnote{The Vivado programming/debugging flow and in-system debug core concepts (including ILA and debug hub behavior) are described in \cite{amd_ug908}.}

\subsubsection{ILA Configuration}
Vivado provides two practical entry points for ILA insertion:
\begin{itemize}
    \item \textbf{GUI workflow:} open the synthesized design, use \textit{Tools $\rightarrow$ Set Up Debug}, and let Vivado discover signals tagged with \texttt{(* mark\_debug = "true" *)}. Vivado then inserts the ILA core, generates the required TCL, and connects probes.
    \item \textbf{TCL workflow:} instantiate/configure the ILA and bind probes explicitly. This offers more control and makes the connection mechanism explicit (internal nets are connected to ILA probes via hierarchical names).
\end{itemize}

\subsubsection{ILA Realization via XDC/TCL}
To make the probing configuration reproducible (and to document exactly which internal nets are observed), the project includes a constraints script that creates and wires an ILA core directly in Tcl/XDC. The full script (including capture-depth settings and explicit hierarchical probe binding) is provided in Appendix~\ref{app:ila_debug_script}.

This approach also demonstrates a practical constraints methodology principle: debug insertion is itself a design-time transformation controlled by scripted constraints (and must therefore be kept consistent with the main timing/clock constraints and build configuration).\footnote{Vivado treats XDC as a Tcl-based constraint language and applies constraints in a defined processing order. See \cite{amd_ug903,amd_ug908}.}

\begin{itemize}
    \item \textbf{Probes:} All 16 GPRs, PC, \texttt{int\_en}, \texttt{IRQ\_TAKE}, \texttt{IRQ\_VECTOR}, Timer0/Timer1 \texttt{int\_req}.
    \item \textbf{Trigger:} \texttt{IRQ\_TAKE == 1} (alternatively, a useful low-level trigger is the register-file write enable, e.g., \texttt{ctrl/rf\_we}, to capture architectural state updates).
    \item \textbf{Capture window:} 2048 samples, 25\% pre-trigger (512 samples before trigger), 75\% post-trigger (1536 samples after).
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.62\linewidth]{figures/trigger_setup.png}
\caption{ILA trigger configuration: triggering on IRQ\_TAKE to capture interrupt handling behavior.}
\label{fig:ila_trigger_setup}
\end{figure}

\subsubsection{Test Scenario: Nested Timer Interrupts}
\begin{itemize}
    \item \textbf{Timer0 (IRQ0):} Counter starts at \texttt{0xFFF0} (triggers first).
    \item \textbf{Timer1 (IRQ1):} Counter starts so it triggers shortly \emph{after} Timer0 enters its ISR.
\end{itemize}

\paragraph{Expected Behavior}
\begin{enumerate}
    \item Timer0 overflows first, \texttt{IRQ\_TAKE} asserts, PC jumps to Timer0 ISR (vector \texttt{0x0020}).
    \item Timer0 ISR executes \texttt{STI}, re-enabling interrupts (allow preemption).
    \item Timer1 overflows while Timer0 ISR is active.
    \item VIC compares priorities: IRQ1 $>$ IRQ0, so Timer1 preempts; PC jumps to Timer1 ISR (vector \texttt{0x0040}).
    \item Timer1 ISR completes and executes \texttt{IRET}; execution returns to the interrupted Timer0 ISR.
    \item Timer0 ISR completes and returns to main.
\end{enumerate}

\subsubsection{ILA Results}
Captured waveforms confirmed:
\begin{itemize}
    \item Nested interrupt preemption occurred correctly.
    \item PC vectoring to \texttt{0x0020} (Timer0) and then to \texttt{0x0040} (Timer1) during preemption.
    \item Register values preserved across nested calls.
    \item No timing violations (all setup/hold checks passed).
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.92\linewidth]{figures/ila_baremetal_run.png}
\caption{ILA capture showing nested interrupt preemption and correct vectoring. Timer0 fires first, followed by Timer1 preempting Timer0's ISR. Waveform signals confirm correct interrupt handling and context preservation, returning via the lr register.}
\label{fig:ila_nested_irq}
\end{figure}

\subsection{Clock Frequency: 80MHz Operational Target}
While post-implementation simulation showed WNS $> 0$ at 100MHz, the physical hardware run used 80MHz for margin. Reasons:
\begin{enumerate}
    \item ILA insertion adds routing congestion.
    \item Temperature variation on FPGA die.
    \item Conservative approach for first hardware bring-up.
\end{enumerate}

Future optimizations (Pblocks, manual placement hints) may enable 100MHz on hardware.

\subsection{Hardware Validation Summary}
Hardware validation on Zybo Z7-10 focuses on externally observable behavior and interrupt-corner cases:
\begin{itemize}
    \item Condition codes are preserved across interrupts using the PSR mechanism and \texttt{GETCC}/\texttt{SETCC}.
    \item Priority-based nesting behavior is observed using timer-driven interrupt sources and ILA capture of PC/vector signals.
    \item Bare-metal programs execute at an 80\,MHz operating point chosen for additional margin under debug instrumentation.
\end{itemize}

\section{Roadmap and Future Work}

\subsection{Timing Optimization}
\begin{itemize}
    \item \textbf{Pblocks:} Placement hints to reduce routing distance for critical paths.
    \item \textbf{Manual LUT mapping:} Force specific logic into adjacent slices.
    \item \textbf{Clock domain partitioning:} Isolate slow peripherals onto separate clock domain with CDC (Clock Domain Crossing) FIFOs.
\end{itemize}

\subsection{Golden Model}
A Python-based instruction-set simulator to:
\begin{enumerate}
    \item Generate reference outputs for RTL testbenches.
    \item Verify correctness of assembler-generated machine code.
    \item Enable automated regression testing.
\end{enumerate}

\subsection{ISA Extensions}
\begin{itemize}
    \item \textbf{Hardware multiplier:} 16x16$\to$32-bit result; may map naturally to FPGA DSP resources depending on implementation choices.
    \item \textbf{Barrel shifter:} Single-cycle arbitrary-width shifts; trades LUT cost against reduced multi-cycle microcode.
\end{itemize}

\subsection{Requirements}
\label{sec:req_trace}
Finally, table \ref{tab:requirements} provides a requirements-to-evidence view, summarizing how each high-level requirement for this project was satisfied, what evidence supports that satisfaction, and where/how the evidence can be reproduced.

\begin{table}[H]
\centering
\small
\begin{tabular}{@{}p{0.08\linewidth}p{0.46\linewidth}p{0.18\linewidth}p{0.22\linewidth}@{}}
\toprule
ID & Requirement & Evidence & Reproduce \\
\midrule
R1 & Bare-metal program executes on Zybo Z7-10 & Sec.~\ref{subsec:quickstart}, Fig.~\ref{fig:ila_nested_irq} & Sec.~\ref{subsubsec:program_ila} \\
R2 & Interrupts handled correctly (entry/return) & Fig.~\ref{fig:interrupt_flow_waveform}, Fig.~\ref{fig:irq_sequence} & Run any timing simulation in Vivado \\
R3 & Vectored interrupt controller provides deterministic vectoring & Sec.~\ref{sec:req_trace} + Fig.~\ref{fig:vic_arch} & Trigger Timer IRQs \\
R4 & Nested interrupts (priority preemption) works & Fig.~\ref{fig:priority_stack_first}, Fig.~\ref{fig:ila_nested_irq} & Enable nesting + run timer scenario \\
R5 & Condition codes preserved across ISRs & Sec.~(PSR/GETCC/SETCC), Fig.~\ref{fig:flag_preservation} & Sim test: cmp/brz with IRQ \\
R6 & ABI specified and validated with a call test & ABI Table + \texttt{add3} listing & Assemble + sim \\
R7 & Post-implementation timing validated at target freq & Sec.~(Timing sim), Table~\ref{tab:metrics} & SDF run script \\
\bottomrule
\end{tabular}
\caption{Requirements. Table mapping high-level requirements to evidence and reproduction steps.}
\label{tab:requirements}
\end{table}

\section{Conclusion}
This system adapts Gray's gr0040 RISC processor to modern FPGAs, achieving:
\begin{enumerate}
    \item \textbf{Architecture modernization:} internal tri-states were eliminated and the SoC harness cleanly separates CPU output (\texttt{cpu\_do}) from CPU input (\texttt{cpu\_di}).
    \item \textbf{Timing-closed execution at 80\,MHz:} a synchronous instruction interface (instruction latch + branch annul) and disciplined register boundaries enabled stable operation on Zybo Z7-10 with margin.
    \item \textbf{Hardware-verified interrupts:} a vectored interrupt controller and gr0041 wrapper provide deterministic vectoring and priority-based nesting.
    \item \textbf{Software enablement:} the two-pass assembler and ABI conventions enable reproducible bare-metal programs and disciplined ISR prologues/epilogues.
\end{enumerate}
\subsection{Implementation Metrics}

\begin{table}[h]
\centering
\caption{Implementation metrics and verification summary}
\label{tab:metrics}
\begin{tabular}{ll}
\hline
\textbf{Metric} & \textbf{Value} \\
\hline
Core frequency (silicon) & 80 MHz \\
Post-implementation WNS & +1.002 ns @ 80 MHz \\
VIC hardware latency & 3 cycles (irq\_take $\rightarrow$ PC redirect) \\
Maximum nesting depth & 2 levels \\
LUT utilization (Zybo Z7-10) & $\sim$450 (with ILA: $\sim$650) \\
BRAM tiles & 2 (1 KiB data + ILA capture buffer) \\
Verification coverage & RR/RI/RRI/MEM/BR/VIC/Timers \\
Testbenches & gr0040 core, Timer16, ISR flow \\
ILA probes & 8 (PC, irq\_take, irq\_vector, int\_en, timers, LR, SP) \\
Assembler output formats & 3 (behavioral hex, BMG COE, RAMB18E1 INIT) \\
\hline
\end{tabular}
\end{table}

\par Table~\ref{tab:metrics} summarizes key quantitative characteristics of the implemented system. These metrics reflect a moderately-sized implementation suitable for embedded deployment while maintaining clarity and hardware-verified correctness.

\par The end result is a compact, comprehensible FPGA CPU ecosystem that is both implementable on commodity 7-series devices and usable from a software perspective (toolchain + ABI + debug strategy). The appendix provides a consolidated implementation reference with code excerpts.

\appendix
\clearpage
\input{implementation}

\clearpage
\input{appendix_ila}

\clearpage
\bibliographystyle{unsrt}
\bibliography{references}

\end{document}